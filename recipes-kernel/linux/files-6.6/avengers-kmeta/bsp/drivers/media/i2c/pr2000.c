// SPDX-License-Identifier: GPL-2.0-only
#include <linux/delay.h>
#include <linux/i2c.h>
#include <linux/module.h>
#include <linux/debugfs.h>

#include <media/v4l2-dev.h>
#include <media/v4l2-device.h>
#include <media/v4l2-common.h>
#include <media/v4l2-subdev.h>

#define PR2K_SET_BIT(var, bit)   ((var) |= (1 << (bit)))
#define PR2K_CLEAR_BIT(var, bit) ((var) &= ~(1 << (bit)))

#define PAGE_SEL        0xFF

#define P0_MAN_IFMT     0x10
#define P0_MIPI_CTRL    0x40
#define P0_MIPI_IN_MD   0x47
#define P0_MIPI_PD_CTRL 0x4E
#define P0_IRQ_CTRL     0x80
#define P0_IRQENA       0x90
#define P0_GPIO_IOB0    0xA0
#define P0_D0           0xD0
#define P0_E0           0xE0
#define P0_PAD_MPP_CTL  0xF1
#define P0_PAD_VD_CTL   0xF2
#define P0_RESET_EN     0xF8

#define P1_00           0x00
#define P1_70           0x70

#define VID_STATUS0_get_DET_IFMT_STD(data)          ((0xC0&(data))>>6)
#define VID_STATUS0_get_DET_IFMT_REF(data)          ((0x30&(data))>>4)
#define VID_STATUS0_get_DET_VIDEO(data)             ((0x08&(data))>>3)
#define VID_STATUS0_get_DET_IFMT_RES0(data)         ((0x07&(data))>>0)

#define FMT_SD_480I  0
#define FMT_SD_576I  1
#define FMT_HD_1080P25 2
#define FMT_HD_1080P30 3
#define FMT_HD_720P25  4
#define FMT_HD_720P30  5
#define FMT_HD_720P50  6
#define FMT_HD_720P60  7
#define FMT_HD_960P25  8
#define FMT_HD_960P30  9

/* of_property bt-mode */
#define MD_BT1120    0
#define MD_BT656     1

/* of_property cascade-mode */
#define CASCADE_OFF    0
#define CASCADE_MASTER 1
#define CASCADE_SLAVE  2

static const char * const str_cam_fmt[] = {
	"FMT_SD_480I", "FMT_SD_576I", "FMT_HD_1080P25", "FMT_HD_1080P30",
	"FMT_HD_720P25", "FMT_HD_720P30", "FMT_HD_720P50", "FMT_HD_720P60",
	"FMT_HD_960P25", "FMT_HD_960P30"
};

static const char * const str_ifmt_std[] = {
	"HD-PVI", "HD-CVI", "HDA", "HDT"
};

static const char * const str_ifmt_ref[] = {
	"25Hz", "30Hz", "50Hz", "60Hz"
};

static const char * const str_ifmt_res[] = {
	"SD 480i", "SD 576i", "HD720p", "HD1080p",
	"HD960p or HD800p", "Unknown", "Unknown", "Unknown"
};

struct regval {
	u8 addr;
	u8 val;
};

struct pr2k_debug {
	struct dentry *debugfs_dir;
	bool en_colorbar;
	bool en_dump_i2c;
};

struct pr2000 {
	struct device *dev;
	struct v4l2_device v4l2_dev;
	struct v4l2_subdev sd;
	struct i2c_client *i2c_client;
	struct gpio_desc *rst_gpio;

	struct pr2k_debug debug;
	u32 format;
	u32 bt_mode;
	u32 cascade_mode;
	bool pll_locked;
	bool video_detected;
};

#define to_pr2k(x) container_of(x, struct pr2000, x)

static const struct regval pr2k_720p25_setting[] = {
	{PAGE_SEL, 0x00},
	{0x12, 0x00},
	{0x13, 0x00},
	{0x14, 0x21},
	{0x15, 0x44},
	{0x16, 0x0D},
	{0x40, 0x00},
	{0x47, 0x3A},
	{0x4E, 0x3F},
	{0x80, 0x56},
	{0x81, 0x0E},
	{0x82, 0x0D},
	{0x84, 0x30},
	{0x86, 0x20},
	{0x87, 0x00},
	{0x8A, 0x00},
	{0x90, 0x00},
	{0x91, 0x00},
	{0x92, 0x00},
	{0x94, 0xFF},
	{0x95, 0xFF},
	{0x96, 0xFF},
	{0xA0, 0x00},
	{0xA1, 0x00},
	{0xA4, 0x01},
	{0xA5, 0xE3},
	{0xA6, 0x00},
	{0xA7, 0x12},
	{0xA8, 0x00},
	{0xD0, 0x30},
	{0xD1, 0x08},
	{0xD2, 0x21},
	{0xD3, 0x00},
	{0xD8, 0x33},
	{0xD9, 0x08},
	{0xDA, 0x21},
	{0x39, 0x35},
	{0xE0, 0x39},
	{0xE1, 0x00},
	{0xE2, 0x18},
	{0xE3, 0x00},
	{0xE4, 0x00},
	{0xEA, 0x02}, /* rtk 0x02 */
	{0xEB, 0xFF},
	{0xF1, 0x44},
	{0xF2, 0x01},
	{PAGE_SEL, 0x01},
	{0x00, 0xE4},
	{0x01, 0x61},
	{0x02, 0x00},
	{0x03, 0x57},
	{0x04, 0x0C},
	{0x05, 0x88},
	{0x06, 0x04},
	{0x07, 0xB2},
	{0x08, 0x44},
	{0x09, 0x34},
	{0x0A, 0x02},
	{0x0B, 0x14},
	{0x0C, 0x04},
	{0x0D, 0x08},
	{0x0E, 0x5E},
	{0x0F, 0x5E},
	{0x10, 0x26},
	{0x11, 0x01},
	{0x12, 0x45},
	{0x13, 0x0C},
	{0x14, 0x00},
	{0x15, 0x1B},
	{0x16, 0xD0},
	{0x17, 0x00},
	{0x18, 0x41},
	{0x19, 0x46},
	{0x1A, 0x22},
	{0x1B, 0x05},
	{0x1C, 0xEA},
	{0x1D, 0x45},
	{0x1E, 0x4C},
	{0x1F, 0x00},
	{0x20, 0x80},
	{0x21, 0x80},
	{0x22, 0x90},
	{0x23, 0x80},
	{0x24, 0x80},
	{0x25, 0x80},
	{0x26, 0x84},
	{0x27, 0x82},
	{0x28, 0x00},
	{0x29, 0x7D},
	{0x2A, 0x00},
	{0x2B, 0x00},
	{0x2C, 0x00},
	{0x2D, 0x00},
	{0x2E, 0x00},
	{0x2F, 0x00},
	{0x30, 0x00},
	{0x31, 0x00},
	{0x32, 0xC0},
	{0x33, 0x14},
	{0x34, 0x14},
	{0x35, 0x80},
	{0x36, 0x80},
	{0x37, 0xAA},
	{0x38, 0x48},
	{0x39, 0x08},
	{0x3A, 0x27},
	{0x3B, 0x02},
	{0x3C, 0x01},
	{0x3D, 0x23},
	{0x3E, 0x02},
	{0x3F, 0xC4},
	{0x40, 0x05},
	{0x41, 0x55},
	{0x42, 0x01},
	{0x43, 0x33},
	{0x44, 0x6A},
	{0x45, 0x00},
	{0x46, 0x09},
	{0x47, 0xE2},
	{0x48, 0x01},
	{0x49, 0x00},
	{0x4A, 0x7B},
	{0x4B, 0x60},
	{0x4C, 0x00},
	{0x4D, 0x4A},
	{0x4E, 0x00},
	{0x4F, 0x20},
	{0x50, 0x01},
	{0x51, 0x28},
	{0x52, 0x40},
	{0x53, 0x0C},
	{0x54, 0x0F},
	{0x55, 0x8D},
	{0x70, 0x06},
	{0x71, 0x08},
	{0x72, 0x0A},
	{0x73, 0x0C},
	{0x74, 0x0E},
	{0x75, 0x10},
	{0x76, 0x12},
	{0x77, 0x14},
	{0x78, 0x06},
	{0x79, 0x08},
	{0x7A, 0x0A},
	{0x7B, 0x0C},
	{0x7C, 0x0E},
	{0x7D, 0x10},
	{0x7E, 0x12},
	{0x7F, 0x14},
	{0x80, 0x00},
	{0x81, 0x09},
	{0x82, 0x00},
	{0x83, 0x07},
	{0x84, 0x00},
	{0x85, 0x17},
	{0x86, 0x03},
	{0x87, 0xE5},
	{0x88, 0x0A},
	{0x89, 0x48},
	{0x8A, 0x0A},
	{0x8B, 0x48},
	{0x8C, 0x0B},
	{0x8D, 0xE0},
	{0x8E, 0x05},
	{0x8F, 0x47},
	{0x90, 0x05},
	{0x91, 0x69},
	{0x92, 0x73},
	{0x93, 0xE8},
	{0x94, 0x0F},
	{0x95, 0x5E},
	{0x96, 0x07},
	{0x97, 0x90},
	{0x98, 0x17},
	{0x99, 0x34},
	{0x9A, 0x13},
	{0x9B, 0x56},
	{0x9C, 0x0B},
	{0x9D, 0x9A},
	{0x9E, 0x09},
	{0x9F, 0xAB},
	{0xA0, 0x01},
	{0xA1, 0x74},
	{0xA2, 0x01},
	{0xA3, 0x6B},
	{0xA4, 0x00},
	{0xA5, 0xBA},
	{0xA6, 0x00},
	{0xA7, 0xA3},
	{0xA8, 0x01},
	{0xA9, 0x39},
	{0xAA, 0x01},
	{0xAB, 0x39},
	{0xAC, 0x00},
	{0xAD, 0xC1},
	{0xAE, 0x00},
	{0xAF, 0xC1},
	{0xB0, 0x0B},
	{0xB1, 0x99},
	{0xB2, 0x12},
	{0xB3, 0xCA},
	{0xB4, 0x00},
	{0xB5, 0x17},
	{0xB6, 0x08},
	{0xB7, 0xE8},
	{0xB8, 0xB0},
	{0xB9, 0xCE},
	{0xBA, 0x90},
	{0xBB, 0x00},
	{0xBC, 0x00},
	{0xBD, 0x04},
	{0xBE, 0x05},
	{0xBF, 0x00},
	{0xC0, 0x00},
	{0xC1, 0x12},
	{0xC2, 0x02},
	{0xC3, 0xD0},
}; /* End of pr2k_720p25_setting */

static const struct regval pr2k_720p30_setting[] = {
	{PAGE_SEL, 0x00},
	{0x12, 0x00},
	{0x13, 0x00},
	{0x14, 0x21},
	{0x15, 0x44},
	{0x16, 0x0D},
	{0x40, 0x00},
	{0x47, 0x3A},
	{0x4E, 0x3F},
	{0x80, 0x56},
	{0x81, 0x0E},
	{0x82, 0x0D},
	{0x84, 0x30},
	{0x86, 0x20},
	{0x87, 0x00},
	{0x8A, 0x00},
	{0x90, 0x00},
	{0x91, 0x00},
	{0x92, 0x00},
	{0x94, 0xFF},
	{0x95, 0xFF},
	{0x96, 0xFF},
	{0xA0, 0x00},
	{0xA1, 0x00},
	{0xA4, 0x01},
	{0xA5, 0xE3},
	{0xA6, 0x00},
	{0xA7, 0x12},
	{0xA8, 0x00},
	{0xD0, 0x30},
	{0xD1, 0x08},
	{0xD2, 0x21},
	{0xD3, 0x00},
	{0xD8, 0x33},
	{0xD9, 0x08},
	{0xDA, 0x21},
	{0x39, 0x35},
	{0xE0, 0x39},
	{0xE1, 0x00},
	{0xE2, 0x18},
	{0xE3, 0x00},
	{0xE4, 0x00},
	{0xEA, 0x02}, /* rtk 0x02 */
	{0xEB, 0xFF},
	{0xF1, 0x44},
	{0xF2, 0x01},
	{PAGE_SEL, 0x01},
	{0x00, 0xE4},
	{0x01, 0x61},
	{0x02, 0x00},
	{0x03, 0x57},
	{0x04, 0x0C},
	{0x05, 0x88},
	{0x06, 0x04},
	{0x07, 0xB2},
	{0x08, 0x44},
	{0x09, 0x34},
	{0x0A, 0x02},
	{0x0B, 0x14},
	{0x0C, 0x04},
	{0x0D, 0x08},
	{0x0E, 0x5E},
	{0x0F, 0x5E},
	{0x10, 0x26},
	{0x11, 0x00},
	{0x12, 0x45},
	{0x13, 0xFC},
	{0x14, 0x00},
	{0x15, 0x18},
	{0x16, 0xD0},
	{0x17, 0x00},
	{0x18, 0x41},
	{0x19, 0x46},
	{0x1A, 0x22},
	{0x1B, 0x05},
	{0x1C, 0xEA},
	{0x1D, 0x45},
	{0x1E, 0x40},
	{0x1F, 0x00},
	{0x20, 0x80},
	{0x21, 0x80},
	{0x22, 0x90},
	{0x23, 0x80},
	{0x24, 0x80},
	{0x25, 0x80},
	{0x26, 0x84},
	{0x27, 0x82},
	{0x28, 0x00},
	{0x29, 0x7B},
	{0x2A, 0xA6},
	{0x2B, 0x00},
	{0x2C, 0x00},
	{0x2D, 0x00},
	{0x2E, 0x00},
	{0x2F, 0x00},
	{0x30, 0x00},
	{0x31, 0x00},
	{0x32, 0xC0},
	{0x33, 0x14},
	{0x34, 0x14},
	{0x35, 0x80},
	{0x36, 0x80},
	{0x37, 0xAA},
	{0x38, 0x48},
	{0x39, 0x08},
	{0x3A, 0x27},
	{0x3B, 0x02},
	{0x3C, 0x01},
	{0x3D, 0x23},
	{0x3E, 0x02},
	{0x3F, 0xC4},
	{0x40, 0x05},
	{0x41, 0x55},
	{0x42, 0x01},
	{0x43, 0x33},
	{0x44, 0x6A},
	{0x45, 0x00},
	{0x46, 0x09},
	{0x47, 0xDC},
	{0x48, 0xA0},
	{0x49, 0x00},
	{0x4A, 0x7B},
	{0x4B, 0x60},
	{0x4C, 0x00},
	{0x4D, 0x4A},
	{0x4E, 0x00},
	{0x4F, 0x20},
	{0x50, 0x01},
	{0x51, 0x28},
	{0x52, 0x40},
	{0x53, 0x0C},
	{0x54, 0x0F},
	{0x55, 0x8D},
	{0x70, 0x06},
	{0x71, 0x08},
	{0x72, 0x0A},
	{0x73, 0x0C},
	{0x74, 0x0E},
	{0x75, 0x10},
	{0x76, 0x12},
	{0x77, 0x14},
	{0x78, 0x06},
	{0x79, 0x08},
	{0x7A, 0x0A},
	{0x7B, 0x0C},
	{0x7C, 0x0E},
	{0x7D, 0x10},
	{0x7E, 0x12},
	{0x7F, 0x14},
	{0x80, 0x00},
	{0x81, 0x09},
	{0x82, 0x00},
	{0x83, 0x07},
	{0x84, 0x00},
	{0x85, 0x17},
	{0x86, 0x03},
	{0x87, 0xE5},
	{0x88, 0x08},
	{0x89, 0x91},
	{0x8A, 0x08},
	{0x8B, 0x91},
	{0x8C, 0x0B},
	{0x8D, 0xE0},
	{0x8E, 0x05},
	{0x8F, 0x47},
	{0x90, 0x05},
	{0x91, 0xA0},
	{0x92, 0x73},
	{0x93, 0xE8},
	{0x94, 0x0F},
	{0x95, 0x5E},
	{0x96, 0x07},
	{0x97, 0x90},
	{0x98, 0x17},
	{0x99, 0x34},
	{0x9A, 0x13},
	{0x9B, 0x56},
	{0x9C, 0x0B},
	{0x9D, 0x9A},
	{0x9E, 0x09},
	{0x9F, 0xAB},
	{0xA0, 0x01},
	{0xA1, 0x74},
	{0xA2, 0x01},
	{0xA3, 0x6B},
	{0xA4, 0x00},
	{0xA5, 0xBA},
	{0xA6, 0x00},
	{0xA7, 0xA3},
	{0xA8, 0x01},
	{0xA9, 0x39},
	{0xAA, 0x01},
	{0xAB, 0x39},
	{0xAC, 0x00},
	{0xAD, 0xC1},
	{0xAE, 0x00},
	{0xAF, 0xC1},
	{0xB0, 0x09},
	{0xB1, 0xAA},
	{0xB2, 0x0F},
	{0xB3, 0xAE},
	{0xB4, 0x00},
	{0xB5, 0x17},
	{0xB6, 0x08},
	{0xB7, 0xE8},
	{0xB8, 0xB0},
	{0xB9, 0xCE},
	{0xBA, 0x90},
	{0xBB, 0x00},
	{0xBC, 0x00},
	{0xBD, 0x04},
	{0xBE, 0x05},
	{0xBF, 0x00},
	{0xC0, 0x00},
	{0xC1, 0x18},
	{0xC2, 0x02},
	{0xC3, 0xD0},
}; /* End of pr2k_720p30_setting */

static const struct regval pr2k_1080p30_setting[] = {
	{PAGE_SEL, 0x00},
	/* {0x10, 0x93}, */
	/* {0x11, 0x00}, */
	{0x12, 0x00},
	{0x13, 0x00},
	{0x14, 0x21},
	{0x15, 0x44},
	{0x16, 0x0D},
	{0x40, 0x00},
	{0x47, 0x3A},
	{0x4E, 0x3F},
	{0x80, 0x56},
	{0x81, 0x0E},
	{0x82, 0x0D},
	{0x84, 0x30},
	{0x86, 0x20},
	{0x87, 0x00},
	{0x8A, 0x00},
	{0x90, 0x00},
	{0x91, 0x00},
	{0x92, 0x00},
	{0x94, 0xFF},
	{0x95, 0xFF},
	{0x96, 0xFF},
	{0xA0, 0x00},
	{0xA1, 0x00},
	{0xA4, 0x01},
	{0xA5, 0xE3},
	{0xA6, 0x00},
	{0xA7, 0x12},
	{0xA8, 0x00},
	{0xD0, 0x30},
	{0xD1, 0x08},
	{0xD2, 0x21},
	{0xD3, 0x00},
	{0xD8, 0x33},
	{0xD9, 0x08},
	{0xDA, 0x21},
	{0xE0, 0x35},
	{0xE1, 0x00},
	{0xE2, 0x18},
	{0xE3, 0x00},
	{0xE4, 0x00},
	{0xEA, 0x02}, /* rtk 0x02 */
	{0xEB, 0xFF},
	{0xF1, 0x44},
	{0xF2, 0x01},
	{PAGE_SEL, 0x01},
	{0x00, 0xE4},
	{0x01, 0x61},
	{0x02, 0x00},
	{0x03, 0x57},
	{0x04, 0x0C},
	{0x05, 0x88},
	{0x06, 0x04},
	{0x07, 0xB2},
	{0x08, 0x44},
	{0x09, 0x34},
	{0x0A, 0x02},
	{0x0B, 0x14},
	{0x0C, 0x04},
	{0x0D, 0x08},
	{0x0E, 0x5E},
	{0x0F, 0x5E},
	{0x10, 0x26},
	{0x11, 0x00},
	{0x12, 0x87},
	{0x13, 0x2C},
	{0x14, 0x80},
	{0x15, 0x28},
	{0x16, 0x38},
	{0x17, 0x00},
	{0x18, 0x80},
	{0x19, 0x48},
	{0x1A, 0x6C},
	{0x1B, 0x05},
	{0x1C, 0x61},
	{0x1D, 0x07},
	{0x1E, 0x7E},
	{0x1F, 0x80},
	{0x20, 0x80},
	{0x21, 0x80},
	{0x22, 0x90},
	{0x23, 0x80},
	{0x24, 0x80},
	{0x25, 0x80},
	{0x26, 0x84},
	{0x27, 0x82},
	{0x28, 0x00},
	{0x29, 0xFF},
	{0x2A, 0xFF},
	{0x2B, 0x00},
	{0x2C, 0x00},
	{0x2D, 0x00},
	{0x2E, 0x00},
	{0x2F, 0x00},
	{0x30, 0x00},
	{0x31, 0x00},
	{0x32, 0xC0},
	{0x33, 0x14},
	{0x34, 0x14},
	{0x35, 0x80},
	{0x36, 0x80},
	{0x37, 0xAD},
	{0x38, 0x4B},
	{0x39, 0x08},
	{0x3A, 0x21},
	{0x3B, 0x02},
	{0x3C, 0x01},
	{0x3D, 0x23},
	{0x3E, 0x05},
	{0x3F, 0xC8},
	{0x40, 0x05},
	{0x41, 0x55},
	{0x42, 0x01},
	{0x43, 0x38},
	{0x44, 0x6A},
	{0x45, 0x00},
	{0x46, 0x14},
	{0x47, 0xB2},
	{0x48, 0xBC},
	{0x49, 0x00},
	{0x4A, 0x7B},
	{0x4B, 0x60},
	{0x4C, 0x00},
	{0x4D, 0x26},
	{0x4E, 0x00},
	{0x4F, 0x20},
	{0x50, 0x01},
	{0x51, 0x28},
	{0x52, 0x40},
	{0x53, 0x0C},
	{0x54, 0x0F},
	{0x55, 0x8D},
	{0x70, 0x06},
	{0x71, 0x08},
	{0x72, 0x0A},
	{0x73, 0x0C},
	{0x74, 0x0E},
	{0x75, 0x10},
	{0x76, 0x12},
	{0x77, 0x14},
	{0x78, 0x06},
	{0x79, 0x08},
	{0x7A, 0x0A},
	{0x7B, 0x0C},
	{0x7C, 0x0E},
	{0x7D, 0x10},
	{0x7E, 0x12},
	{0x7F, 0x14},
	{0x80, 0x00},
	{0x81, 0x09},
	{0x82, 0x00},
	{0x83, 0x07},
	{0x84, 0x00},
	{0x85, 0x17},
	{0x86, 0x03},
	{0x87, 0xE5},
	{0x88, 0x04},
	{0x89, 0x48},
	{0x8A, 0x04},
	{0x8B, 0x48},
	{0x8C, 0x08},
	{0x8D, 0xE8},
	{0x8E, 0x05},
	{0x8F, 0x47},
	{0x90, 0x03},
	{0x91, 0x13},
	{0x92, 0x73},
	{0x93, 0xE8},
	{0x94, 0x0F},
	{0x95, 0x5E},
	{0x96, 0x03},
	{0x97, 0xD0},
	{0x98, 0x17},
	{0x99, 0x34},
	{0x9A, 0x13},
	{0x9B, 0x56},
	{0x9C, 0x0B},
	{0x9D, 0x9A},
	{0x9E, 0x09},
	{0x9F, 0xAB},
	{0xA0, 0x01},
	{0xA1, 0x74},
	{0xA2, 0x01},
	{0xA3, 0x6B},
	{0xA4, 0x00},
	{0xA5, 0xBA},
	{0xA6, 0x00},
	{0xA7, 0xA3},
	{0xA8, 0x01},
	{0xA9, 0x39},
	{0xAA, 0x01},
	{0xAB, 0x39},
	{0xAC, 0x00},
	{0xAD, 0xC1},
	{0xAE, 0x00},
	{0xAF, 0xC1},
	{0xB0, 0x04},
	{0xB1, 0xD4},
	{0xB2, 0x07},
	{0xB3, 0xDA},
	{0xB4, 0x00},
	{0xB5, 0x17},
	{0xB6, 0x08},
	{0xB7, 0xE8},
	{0xB8, 0xB0},
	{0xB9, 0xCE},
	{0xBA, 0x90},
	{0xBB, 0x00},
	{0xBC, 0x00},
	{0xBD, 0x04},
	{0xBE, 0x07},
	{0xBF, 0x80},
	{0xC0, 0x00},
	{0xC1, 0x20},
	{0xC2, 0x04},
	{0xC3, 0x38},
	/* {0xFF, 0x01}, */
	/* {0x54, 0x0E}, */
	/* {0xFF, 0x01}, */
	/* {0x54, 0x0F}, */
};

/* P0_MAN_IFMT 0x10 */
static const u8 p0_main_480i[] = {
	0x30, 0x00, 0x00, 0x00, 0x21, 0x44, 0x0D
};

static const u8 p0_main_576i[] = {
	0x21, 0x00, 0x00, 0x00, 0x21, 0x44, 0x0D
};

/* P0_IRQ_CTRL 0x80 - 0x8A */
static const u8 p0_irq_ctrl_480i[] = {
	0x56, 0x0E, 0x0D, 0x00, 0x30, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00
};

/* P0_IRQENA 0x90 -0x96 */
static const u8 p0_irqena_480i[] = {
	0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF
};

/* P0_GPIO_IOB0 0xA0 -0xA8 */
static const u8 p0_gpio_iob0_480i[] = {
	0x01, 0xE8, 0x00, 0x00, 0x00, 0x11, 0x00, 0x81, 0x00
};

static const u8 p0_gpio_iob0_576i[] = {
	0x00, 0x00, 0x00, 0x00, 0x01, 0xE3, 0x00, 0x12, 0x00
};

/* P0_D0 0xD0 - 0xDA */
static const u8 p0_d0_480i[] = {
	0x30, 0x08, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0x08, 0x18
};

/* P0_E0 0xE0 - 0xEB */
static const u8 p0_e0_480i[] = {
	0x3E, 0xB0, 0x18, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xFF
};

/* P1_00 0x00 */
static const u8 p1_00_480i[] = {
	/* 0x00 - 0x07 */
	0xE4, 0x61, 0x00, 0x57, 0x0C, 0x88, 0x04, 0xB2,
	/* 0x08 - 0x0F */
	0x44, 0x34, 0x02, 0x14, 0x04, 0x08, 0x5E, 0x5E,
	/* 0x10 - 0x17 */
	0x26, 0x00, 0x02, 0x90, 0xD0, 0x10, 0xF0, 0x00,
	/* 0x18 - 0x1F */
	0x21, 0x4A, 0x20, 0x07, 0x00, 0x42, 0x40, 0xD0,
	/* 0x20 - 0x27 */
	0x80, 0x88, 0x80, 0x80, 0x80, 0x80, 0x84, 0x80,
	/* 0x28 - 0x2F */
	0x00, 0x5F, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* 0x30 - 0x37 */
	0x00, 0x00, 0xC0, 0x14, 0x14, 0x80, 0x80, 0xE2,
	/* 0x38 - 0x3F */
	0x41, 0x00, 0xAC, 0x04, 0x01, 0x21, 0x06, 0xD5,
	/* 0x40 - 0x47 */
	0x05, 0x55, 0x01, 0x30, 0x6A, 0x00, 0x06, 0x2B,
	/* 0x48 - 0x4F */
	0xB9, 0x00, 0x7B, 0x60, 0x00, 0x47, 0x02, 0x20,
	/* 0x50 - 0x57 */
	0x01, 0x28, 0x40, 0x0C, 0x0F, 0x8D
};

static const u8 p1_00_576i[] = {
	/* 0x00 - 0x07 */
	0xE4, 0x61, 0x00, 0x57, 0x0C, 0x88, 0x04, 0xB2,
	/* 0x08 - 0x0F */
	0x44, 0x34, 0x02, 0x14, 0x04, 0x08, 0x5E, 0x5E,
	/* 0x10 - 0x17 */
	0x26, 0x00, 0x22, 0xE0, 0xD0, 0x16, 0x20, 0x00,
	/* 0x18 - 0x1F */
	0x21, 0x4A, 0x20, 0x06, 0x31, 0x42, 0x50, 0xD0,
	/* 0x20 - 0x27 */
	0x80, 0x88, 0x80, 0x80, 0x80, 0x80, 0x84, 0x80,
	/* 0x28 - 0x2F */
	0x00, 0x5F, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* 0x30 - 0x37 */
	0x00, 0x00, 0xC0, 0x20, 0x20, 0x10, 0x10, 0xC4,
	/* 0x38 - 0x3F */
	0x42, 0x00, 0xAC, 0x04, 0x01, 0x21, 0x06, 0xD5,
	/* 0x40 - 0x47 */
	0x85, 0x55, 0x01, 0x31, 0x6A, 0x00, 0x07, 0xA4,
	/* 0x48 - 0x4F */
	0xA5, 0x00, 0x7B, 0x60, 0x00, 0x47, 0x02, 0x20,
	/* 0x50 - 0x57 */
	0x01, 0x28, 0x40, 0x0C, 0x0F, 0x8D
};

/* P1_70 0x70 */
static const u8 p1_70_480i[] = {
	/* 0x70 - 0x77 */
	0x06, 0x08, 0x0A, 0x0C, 0x0E, 0x10, 0x12, 0x14,
	/* 0x78 - 0x7F */
	0x06, 0x08, 0x0A, 0x0C, 0x0E, 0x10, 0x12, 0x14,
	/* 0x80 - 0x87 */
	0x00, 0x09, 0x00, 0x07, 0x00, 0x17, 0x03, 0xE5,
	/* 0x88 - 0x8F */
	0x05, 0x48, 0x04, 0x48, 0x05, 0xF0, 0x05, 0x47,
	/* 0x90 - 0x97 */
	0x03, 0x13, 0x73, 0xE8, 0x0F, 0x5E, 0x03, 0xD0,
	/* 0x98 - 0x9F */
	0x17, 0x34, 0x13, 0x56, 0x0B, 0x9A, 0x09, 0xAB,
	/* 0xA0 - 0xA7 */
	0x01, 0x74, 0x01, 0x6B, 0x00, 0xBA, 0x00, 0xA3,
	/* 0xA8 - 0xAF */
	0x01, 0x39, 0x01, 0x39, 0x00, 0xC1, 0x00, 0xC1,
	/* 0xB0 - 0xB7 */
	0x04, 0xD4, 0x07, 0x6D, 0x00, 0x17, 0x08, 0xE8,
	/* 0xB8 - 0xBF */
	0xB0, 0xCE, 0x90, 0x10, 0x00, 0x04, 0x02, 0xD0,
	/* 0xC0 - 0xC8 */
	0x00, 0x10, 0x00, 0xF0
};

static const u8 p1_70_576i[] = {
	/* 0x70 - 0x77 */
	0x06, 0x08, 0x0A, 0x0C, 0x0E, 0x10, 0x12, 0x14,
	/* 0x78 - 0x7F */
	0x06, 0x08, 0x0A, 0x0C, 0x0E, 0x10, 0x12, 0x14,
	/* 0x80 - 0x87 */
	0x00, 0x09, 0x00, 0x07, 0x00, 0x17, 0x03, 0xE5,
	/* 0x88 - 0x8F */
	0x05, 0x24, 0x05, 0x24, 0x05, 0xF0, 0x05, 0x47,
	/* 0x90 - 0x97 */
	0x02, 0xB4, 0x73, 0xE8, 0x0F, 0x5E, 0x03, 0xD0,
	/* 0x98 - 0x9F */
	0x17, 0x34, 0x13, 0x56, 0x0B, 0x9A, 0x09, 0xAB,
	/* 0xA0 - 0xA7 */
	0x01, 0x74, 0x01, 0x6B, 0x00, 0xBA, 0x00, 0xA3,
	/* 0xA8 - 0xAF */
	0x01, 0x39, 0x01, 0x39, 0x00, 0xC1, 0x00, 0xC1,
	/* 0xB0 - 0xB7 */
	0x05, 0xCC, 0x09, 0x6D, 0x00, 0x17, 0x08, 0xE8,
	/* 0xB8 - 0xBF */
	0xB0, 0xCE, 0x90, 0x10, 0x00, 0x04, 0x02, 0xD0,
	/* 0xC0 - 0xC8 */
	0x00, 0x16, 0x01, 0x20
};

static int pr2k_write_reg(struct v4l2_subdev *sd, u8 reg, u8 value)
{
	struct i2c_client *client = v4l2_get_subdevdata(sd);
	struct pr2000 *pr2k = to_pr2k(sd);
	struct pr2k_debug *debug = &pr2k->debug;

	if (debug->en_dump_i2c)
		dev_info(pr2k->dev, "Write 0x%02x = 0x%02x", reg, value);

	return i2c_smbus_write_byte_data(client, reg, value);
}

static int pr2k_write_block(struct v4l2_subdev *sd, u8 reg, u8 length, const u8 *values)
{
	struct i2c_client *client = v4l2_get_subdevdata(sd);
	struct pr2000 *pr2k = to_pr2k(sd);
	s32 ret;
	u8 remain_bytes;
	u8 w_bytes;
	u8 index;

	remain_bytes = length;
	for (index = 0; index < length; index += w_bytes) {

		/* SMBus allows at most 32 bytes */
		if (remain_bytes > I2C_SMBUS_BLOCK_MAX)
			w_bytes = I2C_SMBUS_BLOCK_MAX;
		else
			w_bytes = remain_bytes;

		ret = i2c_smbus_write_i2c_block_data(client, reg + index, w_bytes, &values[index]);
		if (ret < 0) {
			dev_err(pr2k->dev, "Failed to write Reg0x%02x block %ubytes, ret=%d",
				reg + index, w_bytes, ret);
			break;
		}

		remain_bytes = remain_bytes - w_bytes;
	}

	return ret;
}

static int pr2k_read_reg(struct v4l2_subdev *sd, u8 reg)
{
	struct i2c_client *client = v4l2_get_subdevdata(sd);
	struct pr2000 *pr2k = to_pr2k(sd);
	struct pr2k_debug *debug = &pr2k->debug;
	int reg_val;

	reg_val = i2c_smbus_read_byte_data(client, reg);

	if (debug->en_dump_i2c && (reg_val >= 0))
		dev_info(pr2k->dev, "Read 0x%02x = 0x%02x", reg, (u8)reg_val);

	return reg_val;
}

static void pr2k_soft_rest(struct v4l2_subdev *sd)
{
	struct i2c_client *client = v4l2_get_subdevdata(sd);

	i2c_smbus_write_byte_data(client, PAGE_SEL, 0x0);
	i2c_smbus_write_byte_data(client, P0_RESET_EN, 0x7f);
	i2c_smbus_write_byte_data(client, P0_RESET_EN, 0x0);
}

static bool pr2k_signal_det(struct v4l2_subdev *sd)
{
	struct i2c_client *client = v4l2_get_subdevdata(sd);
	struct pr2000 *pr2k = to_pr2k(sd);
	u8 vid_status0;
	u8 vid_status1;

	i2c_smbus_write_byte_data(client, PAGE_SEL, 0x0);

	vid_status0 = pr2k_read_reg(sd, 0x0);
	vid_status1 = pr2k_read_reg(sd, 0x1);

	if (vid_status1 == 0xff) {
		pr2k->pll_locked = true;

		if (VID_STATUS0_get_DET_VIDEO(vid_status0)) {
			u8 std;
			u8 ref;
			u8 res;

			pr2k->video_detected = true;

			std = VID_STATUS0_get_DET_IFMT_STD(vid_status0);
			ref = VID_STATUS0_get_DET_IFMT_REF(vid_status0);
			res = VID_STATUS0_get_DET_IFMT_RES0(vid_status0);

			dev_info(pr2k->dev, "Format %s %s %s",
				str_ifmt_std[std&0x3], str_ifmt_res[res&0x7], str_ifmt_ref[ref&0x3]);
		}
	} else {
		dev_info(pr2k->dev, "VID_STATUS0=0x%02x", vid_status0);
		dev_info(pr2k->dev, "VID_STATUS1=0x%02x", vid_status1);
		pr2k->pll_locked = false;
		pr2k->video_detected = false;
	}

	return pr2k->video_detected;
}

static int pr2k_s_power(struct v4l2_subdev *sd, int on)
{
	struct pr2000 *pr2k = to_pr2k(sd);

	dev_info(pr2k->dev, "s_power %s", on ? "on":"off");

	if (pr2k->rst_gpio == NULL) {
		dev_info(pr2k->dev, "skip rest control");
		goto exit;
	}

	/* power on -> don't rest */
	gpiod_set_value_cansleep(pr2k->rst_gpio, on ? 0:1);

exit:
	return 0;
}

static int pr2k_480i_init_cfg(struct v4l2_subdev *sd)
{
	struct pr2000 *pr2k = to_pr2k(sd);

	dev_dbg(pr2k->dev, "%s", __func__);

	pr2k_soft_rest(sd);

	/* Page 0 */
	pr2k_write_block(sd, P0_MAN_IFMT, ARRAY_SIZE(p0_main_480i), &p0_main_480i[0]);

	pr2k_write_reg(sd, P0_MIPI_CTRL, 0x0);
	pr2k_write_reg(sd, P0_MIPI_IN_MD, 0x36);
	pr2k_write_reg(sd, P0_MIPI_PD_CTRL, 0x3F);

	pr2k_write_block(sd, P0_IRQ_CTRL, ARRAY_SIZE(p0_irq_ctrl_480i), &p0_irq_ctrl_480i[0]);
	pr2k_write_block(sd, P0_IRQENA, ARRAY_SIZE(p0_irqena_480i), &p0_irqena_480i[0]);
	pr2k_write_block(sd, P0_GPIO_IOB0, ARRAY_SIZE(p0_gpio_iob0_480i), &p0_gpio_iob0_480i[0]);
	pr2k_write_block(sd, P0_D0, ARRAY_SIZE(p0_d0_480i), &p0_d0_480i[0]);
	pr2k_write_block(sd, P0_E0, ARRAY_SIZE(p0_e0_480i), &p0_e0_480i[0]);

	pr2k_write_reg(sd, P0_PAD_MPP_CTL, 0x44);
	pr2k_write_reg(sd, P0_PAD_VD_CTL, 0x1);

	/* Page 1 */
	pr2k_write_reg(sd, PAGE_SEL, 0x01);
	pr2k_write_block(sd, P1_00, ARRAY_SIZE(p1_00_480i), &p1_00_480i[0]);
	pr2k_write_block(sd, P1_70, ARRAY_SIZE(p1_70_480i), &p1_70_480i[0]);

	pr2k_write_reg(sd, PAGE_SEL, 0x01);
	pr2k_write_reg(sd, 0x54, 0x0E);
	pr2k_write_reg(sd, PAGE_SEL, 0x01);
	pr2k_write_reg(sd, 0x54, 0x0F);

	return 0;
}

static int pr2k_576i_init_cfg(struct v4l2_subdev *sd)
{
	struct pr2000 *pr2k = to_pr2k(sd);

	dev_dbg(pr2k->dev, "%s", __func__);

	pr2k_soft_rest(sd);

	/* Page 0 */
	pr2k_write_block(sd, P0_MAN_IFMT, ARRAY_SIZE(p0_main_576i), &p0_main_576i[0]);

	pr2k_write_reg(sd, P0_MIPI_CTRL, 0x0);
	pr2k_write_reg(sd, P0_MIPI_IN_MD, 0x36);
	pr2k_write_reg(sd, P0_MIPI_PD_CTRL, 0x3F);

	pr2k_write_block(sd, P0_IRQ_CTRL, ARRAY_SIZE(p0_irq_ctrl_480i), &p0_irq_ctrl_480i[0]);
	pr2k_write_block(sd, P0_IRQENA, ARRAY_SIZE(p0_irqena_480i), &p0_irqena_480i[0]);
	pr2k_write_block(sd, P0_GPIO_IOB0, ARRAY_SIZE(p0_gpio_iob0_576i), &p0_gpio_iob0_576i[0]);
	pr2k_write_block(sd, P0_D0, ARRAY_SIZE(p0_d0_480i), &p0_d0_480i[0]);
	pr2k_write_block(sd, P0_E0, ARRAY_SIZE(p0_e0_480i), &p0_e0_480i[0]);

	pr2k_write_reg(sd, P0_PAD_MPP_CTL, 0x44);
	pr2k_write_reg(sd, P0_PAD_VD_CTL, 0x1);

	/* Page 1 */
	pr2k_write_reg(sd, PAGE_SEL, 0x01);
	pr2k_write_block(sd, P1_00, ARRAY_SIZE(p1_00_576i), &p1_00_576i[0]);
	pr2k_write_block(sd, P1_70, ARRAY_SIZE(p1_70_576i), &p1_70_576i[0]);

	pr2k_write_reg(sd, PAGE_SEL, 0x01);
	pr2k_write_reg(sd, 0x54, 0x0E);
	pr2k_write_reg(sd, PAGE_SEL, 0x01);
	pr2k_write_reg(sd, 0x54, 0x0F);

	return 0;
}

static int pr2k_720p25_init_cfg(struct v4l2_subdev *sd)
{
	struct pr2000 *pr2k = to_pr2k(sd);
	int i;

	dev_dbg(pr2k->dev, "%s", __func__);

	for (i = 0; i < ARRAY_SIZE(pr2k_720p25_setting); i++)
		pr2k_write_reg(sd, pr2k_720p25_setting[i].addr, pr2k_720p25_setting[i].val);

	return 0;
}

static int pr2k_720p30_init_cfg(struct v4l2_subdev *sd)
{
	struct pr2000 *pr2k = to_pr2k(sd);
	int i;

	dev_dbg(pr2k->dev, "%s", __func__);

	for (i = 0; i < ARRAY_SIZE(pr2k_720p30_setting); i++)
		pr2k_write_reg(sd, pr2k_720p30_setting[i].addr, pr2k_720p30_setting[i].val);

	return 0;
}

static int pr2k_1080p30_init_cfg(struct v4l2_subdev *sd)
{
	struct pr2000 *pr2k = to_pr2k(sd);
	int i;

	dev_dbg(pr2k->dev, "%s", __func__);

	for (i = 0; i < ARRAY_SIZE(pr2k_1080p30_setting); i++)
		pr2k_write_reg(sd, pr2k_1080p30_setting[i].addr, pr2k_1080p30_setting[i].val);

	return 0;
}

static int pr2k_format_cfg(struct v4l2_subdev *sd)
{
	struct pr2000 *pr2k = to_pr2k(sd);
	unsigned long timer;
	u32 time_ms;
	int ret;

	timer = jiffies;

	switch (pr2k->format) {
	case FMT_SD_480I:
		ret = pr2k_480i_init_cfg(sd);
		break;
	case FMT_SD_576I:
		ret = pr2k_576i_init_cfg(sd);
		break;
	case FMT_HD_720P25:
		ret = pr2k_720p25_init_cfg(sd);
		break;
	case FMT_HD_720P30:
		ret = pr2k_720p30_init_cfg(sd);
		break;
	case FMT_HD_1080P30:
		ret = pr2k_1080p30_init_cfg(sd);
		break;
	default:
		dev_err(pr2k->dev, "Currently not supported %s", str_cam_fmt[pr2k->format]);
		ret = -ENOEXEC;
		break;
	}

	if (!ret) {
		int i;
		bool video_detected = false;

		time_ms = jiffies_to_msecs(jiffies - timer);

		dev_info(pr2k->dev, "%s init done, cost %u ms",
			str_cam_fmt[pr2k->format], time_ms);

		for (i = 0; i < 5; i++) {
			video_detected = pr2k_signal_det(sd);
			dev_info(pr2k->dev, "video_detected=%u", video_detected);

			if (video_detected)
				break;

			msleep(500);
		}
	}

	return ret;
}

static int pr2k_cascade_cfg(struct v4l2_subdev *sd, u32 cascade_mode)
{
	struct pr2000 *pr2k = to_pr2k(sd);
	unsigned long timer;
	u32 time_ms;
	u8 reg_val;

	timer = jiffies;

	if (cascade_mode == CASCADE_MASTER) {
		pr2k_write_reg(sd, PAGE_SEL, 0x00);
		/* 0xE0[4]=0, set cascade mode power on */
		reg_val = pr2k_read_reg(sd, 0xE0);
		PR2K_CLEAR_BIT(reg_val, 4);
		pr2k_write_reg(sd, 0xE0, reg_val);

		/* 0xE1[2]=1 , [1]=1, 2CH multiplexing outout mode , 2nd data from cascade connection */
		reg_val = pr2k_read_reg(sd, 0xE1);
		PR2K_SET_BIT(reg_val, 2);
		PR2K_SET_BIT(reg_val, 1);
		pr2k_write_reg(sd, 0xE1, reg_val);

		/* 0xE2[7]=1, DDR mode */
		/* 0xE2[1:0]=2,  SET CHID_NUM=2 */
		reg_val = pr2k_read_reg(sd, 0xE2);
		PR2K_SET_BIT(reg_val, 7);
		PR2K_SET_BIT(reg_val, 1);
		PR2K_CLEAR_BIT(reg_val, 0);
		pr2k_write_reg(sd, 0xE2, reg_val);

		/* 0xF2 [5:4]=3, [1:0]=3, increase driving */
		reg_val = pr2k_read_reg(sd, 0xF2);
		PR2K_SET_BIT(reg_val, 5);
		PR2K_SET_BIT(reg_val, 4);
		PR2K_SET_BIT(reg_val, 1);
		PR2K_SET_BIT(reg_val, 0);
		pr2k_write_reg(sd, 0xF2, reg_val);

		/* 0xA0=0x01, MPP SPI input mode */
		pr2k_write_reg(sd, 0xA0, 0x01);
		/* 0xA1=0xff, MPP SPI input mode */
		pr2k_write_reg(sd, 0xA1, 0xff);

		pr2k_write_reg(sd, PAGE_SEL, 0x01);
		/* 1x4E=0x0 */
		pr2k_write_reg(sd, 0x4E, 0x0);

		/* 1x4F[2]=1, enable CHID insertion */
		/* 1x4F[5], 0-BT1120 1-BT656 */
		reg_val = pr2k_read_reg(sd, 0x4F);
		PR2K_SET_BIT(reg_val, 2);

		if (pr2k->bt_mode == MD_BT656)
			PR2K_SET_BIT(reg_val, 5);
		else
			PR2K_CLEAR_BIT(reg_val, 5);

		pr2k_write_reg(sd, 0x4F, reg_val);
	} else if (cascade_mode == CASCADE_SLAVE) {
		pr2k_write_reg(sd, PAGE_SEL, 0x00);
		/* 0xE2 [1:0]=1, SET CHID_NUM=1 */
		reg_val = pr2k_read_reg(sd, 0xE2);
		PR2K_CLEAR_BIT(reg_val, 1);
		PR2K_SET_BIT(reg_val, 0);
		pr2k_write_reg(sd, 0xE2, reg_val);

		/* 0xF2 [5:4]=3, [1:0]=3, increase driving */
		reg_val = pr2k_read_reg(sd, 0xF2);
		PR2K_SET_BIT(reg_val, 5);
		PR2K_SET_BIT(reg_val, 4);
		PR2K_SET_BIT(reg_val, 1);
		PR2K_SET_BIT(reg_val, 0);
		pr2k_write_reg(sd, 0xF2, reg_val);

		pr2k_write_reg(sd, PAGE_SEL, 0x01);
		/* 1x4E=0x0 */
		pr2k_write_reg(sd, 0x4E, 0x0);

		/* 1x4F[2]=1, enable CHID insertion */
		reg_val = pr2k_read_reg(sd, 0x4F);
		PR2K_SET_BIT(reg_val, 2);
		pr2k_write_reg(sd, 0x4F, reg_val);
	}

	time_ms = jiffies_to_msecs(jiffies - timer);
	dev_info(pr2k->dev, "cascade_mode=%u config done, cost %u ms",
			cascade_mode, time_ms);

	return 0;
}

static int en_colorbar_set(void *data, u64 val)
{
	struct pr2000 *pr2k = data;
	struct v4l2_subdev *sd = &pr2k->sd;

	if (val) {
		pr2k_write_reg(sd, PAGE_SEL, 0x00);
		pr2k_write_reg(sd, 0x10, 0x93);
		pr2k_write_reg(sd, 0x11, 0x07);
		pr2k_write_reg(sd, PAGE_SEL, 0x01);
		pr2k_write_reg(sd, 0x4F, 0x30);
		pr2k_write_reg(sd, PAGE_SEL, 0x02);
		pr2k_write_reg(sd, 0x80, 0xB0);
		pr2k_write_reg(sd, 0x82, 0xA0);
	} else {
		pr2k_write_reg(sd, PAGE_SEL, 0x01);
		pr2k_write_reg(sd, 0x4F, 0x20);
		pr2k_write_reg(sd, PAGE_SEL, 0x02);
		pr2k_write_reg(sd, 0x80, 0x08);
		pr2k_write_reg(sd, 0x82, 0x00);
	}

	pr2k->debug.en_colorbar = val ? true:false;

	return 0;
}

static int en_colorbar_get(void *data, u64 *val)
{
	struct pr2000 *pr2k = data;

	*val = (u64)pr2k->debug.en_colorbar;

	return 0;
}

DEFINE_DEBUGFS_ATTRIBUTE(pr2k_dbg_colorbar_fops, en_colorbar_get, en_colorbar_set,
			 "%llu\n");

static int format_set(void *data, u64 val)
{
	struct pr2000 *pr2k = data;
	struct v4l2_subdev *sd = &pr2k->sd;
	int ret;

	if ((val != FMT_SD_480I) && (val != FMT_SD_576I) &&
		(val != FMT_HD_1080P25) && (val != FMT_HD_1080P30) &&
		(val != FMT_HD_720P25) && (val != FMT_HD_720P30) &&
		(val != FMT_HD_720P50) && (val != FMT_HD_720P60) &&
		(val != FMT_HD_960P25) && (val != FMT_HD_960P30)) {
		ret = -EINVAL;
		goto exit;
	}

	pr2k->format = val;

	if (pr2k->rst_gpio != NULL) {
		pr2k_s_power(&pr2k->sd, false);
		msleep(500);
		pr2k_s_power(&pr2k->sd, true);
	}

	ret = pr2k_format_cfg(sd);
	if (ret)
		goto exit;

	if (pr2k->cascade_mode)
		ret = pr2k_cascade_cfg(sd, pr2k->cascade_mode);

exit:
	return ret;
}

static int format_get(void *data, u64 *val)
{
	struct pr2000 *pr2k = data;

	*val = (u64)pr2k->format;

	return 0;
}

DEFINE_DEBUGFS_ATTRIBUTE(pr2k_dbg_format_fops, format_get, format_set,
			 "%llu\n");

static void pr2k_setup_dbgfs(struct pr2000 *pr2k)
{
	struct pr2k_debug *debug = &pr2k->debug;
	struct v4l2_subdev *sd = &pr2k->sd;
	struct i2c_client *client = v4l2_get_subdevdata(sd);
	char name[16];

	snprintf(name, 16, "pr2k_%02x", client->addr);
	debug->debugfs_dir = debugfs_create_dir(name, NULL);
	debug->en_colorbar = false;
	debug->en_dump_i2c = false;

	if (IS_ERR_OR_NULL(debug->debugfs_dir)) {
		dev_info(pr2k->dev, "DebugFS unsupported\n");
		return;
	}

	debugfs_create_file("en_colorbar", 0644, debug->debugfs_dir, pr2k,
			&pr2k_dbg_colorbar_fops);
	debugfs_create_file("format", 0644, debug->debugfs_dir, pr2k,
			&pr2k_dbg_format_fops);
	debugfs_create_bool("en_dump_i2c", 0644, debug->debugfs_dir,
		&debug->en_dump_i2c);

}

static int pr2k_get_fmt(struct v4l2_subdev *sd,
		struct v4l2_subdev_state *state, struct v4l2_subdev_format *format)
{
	int ret = 0;
	struct pr2000 *pr2k = to_pr2k(sd);

	dev_dbg(pr2k->dev, "%s\n", __func__);

	switch (pr2k->format) {
	case FMT_SD_480I:
		format->format.width = 720;
		format->format.height = 480;
		break;
	case FMT_SD_576I:
		format->format.width = 720;
		format->format.height = 576;
		break;
	case FMT_HD_720P25:
	case FMT_HD_720P30: /* FALLTHROUGH */
	case FMT_HD_720P50: /* FALLTHROUGH */
	case FMT_HD_720P60: /* FALLTHROUGH */
		format->format.width = 1280;
		format->format.height = 720;
		break;
	case FMT_HD_1080P25:
	case FMT_HD_1080P30: /* FALLTHROUGH */
		format->format.width = 1920;
		format->format.height = 1080;
		break;
	case FMT_HD_960P25:
	case FMT_HD_960P30: /* FALLTHROUGH */
		format->format.width = 1280;
		format->format.height = 960;
		break;
	default:
		ret = -ENXIO;
		break;
	}

	return ret;
}

static int pr2k_set_fmt(struct v4l2_subdev *sd,
		struct v4l2_subdev_state *state, struct v4l2_subdev_format *format)
{
	struct pr2000 *pr2k = to_pr2k(sd);
	int ret;

	dev_dbg(pr2k->dev, "%s\n", __func__);

	if (pr2k->rst_gpio != NULL) {
		pr2k_s_power(sd, false);
		msleep(500);
		pr2k_s_power(sd, true);
	}

	ret = pr2k_format_cfg(sd);
	if (ret)
		goto exit;

	if (pr2k->cascade_mode)
		ret = pr2k_cascade_cfg(sd, pr2k->cascade_mode);

exit:
	return ret;
}

static const struct v4l2_subdev_core_ops pr2k_core_ops = {
	.s_power = pr2k_s_power,
};

static const struct v4l2_subdev_pad_ops pr2k_pad_ops = {
	/* VIDIOC_SUBDEV_G_FMT handler */
	.get_fmt = pr2k_get_fmt,
	/* VIDIOC_SUBDEV_S_FMT handler */
	.set_fmt = pr2k_set_fmt,
};

static const struct v4l2_subdev_ops pr2k_subdev_ops = {
	.core = &pr2k_core_ops,
	.pad = &pr2k_pad_ops,
};

static const struct media_entity_operations pr2k_entity_ops = {
	.link_validate = v4l2_subdev_link_validate,
};

static int pr2k_probe(struct i2c_client *client)
{
	struct device *dev = &client->dev;
	struct pr2000 *pr2k;
	int ret;

	pr2k = devm_kzalloc(dev, sizeof(*pr2k), GFP_KERNEL);
	if (!pr2k)
		return -ENOMEM;

	pr2k->i2c_client = client;
	pr2k->dev = dev;

	pr2k->rst_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
	if (IS_ERR(pr2k->rst_gpio)) {
		dev_err(dev, "Cannot get reset gpio\n");
		pr2k->rst_gpio = NULL;
	}

	ret = of_property_read_u32(dev->of_node, "camera-fmt",
				&pr2k->format);
	if (ret < 0 || pr2k->format > FMT_HD_960P30)
		pr2k->format = FMT_HD_1080P30;

	dev_info(dev, "Camera format=%s\n", str_cam_fmt[pr2k->format]);

	ret = of_property_read_u32(dev->of_node, "bt-mode",
				&pr2k->bt_mode);
	if (ret < 0 || pr2k->bt_mode > MD_BT656)
		pr2k->bt_mode = MD_BT1120;

	dev_info(dev, "bt_mode=%u\n", pr2k->bt_mode);

	ret = of_property_read_u32(dev->of_node, "cascade-mode",
				&pr2k->cascade_mode);
	if (ret < 0 || pr2k->cascade_mode > CASCADE_SLAVE)
		pr2k->cascade_mode = CASCADE_OFF;

	dev_info(dev, "cascade_mode=%u\n", pr2k->cascade_mode);

	ret = v4l2_device_register(pr2k->dev, &pr2k->v4l2_dev);
	if (ret) {
		dev_err(pr2k->dev, "Failed to register v4l2 device, ret=%d\n", ret);
		goto free_gpio;
	}

	v4l2_i2c_subdev_init(&pr2k->sd, client, &pr2k_subdev_ops);
	pr2k->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;

	ret = v4l2_device_register_subdev(&pr2k->v4l2_dev, &pr2k->sd);
	if (ret) {
		dev_err(pr2k->dev, "Failed to register v4l2 subdev, ret=%d\n", ret);
		goto free_gpio;
	}

	ret = v4l2_device_register_subdev_nodes(&pr2k->v4l2_dev);
	if (ret) {
		dev_err(pr2k->dev, "Failed to register v4l2 subdev node, ret=%d\n", ret);
		goto free_gpio;
	}

	if (IS_ENABLED(CONFIG_DEBUG_FS))
		pr2k_setup_dbgfs(pr2k);

	return 0;

free_gpio:
	if (pr2k->rst_gpio)
		devm_gpiod_put(dev, pr2k->rst_gpio);

	return ret;
}

static int pr2k_remove(struct i2c_client *client)
{

	return 0;
}

static const struct of_device_id pr2k_of_match[] = {
	{ .compatible = "pixelplus,pr2k" },
	{ }
};

MODULE_DEVICE_TABLE(of, pr2k_of_match);

static struct i2c_driver pr2k_driver = {
	.probe_new = pr2k_probe,
	.remove = pr2k_remove,
	.driver = {
		.name = "pr2k",
		.of_match_table = pr2k_of_match,
	},
};

module_i2c_driver(pr2k_driver);

MODULE_DESCRIPTION("PIXELPLUS PR2000KA Driver");
MODULE_AUTHOR("Chase Yen <chase.yen@realtek.com>");
MODULE_LICENSE("GPL v2");
