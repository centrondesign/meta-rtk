// SPDX-License-Identifier: GPL-2.0-only
/*
 * Copyright (c) 2024 Realtek Semiconductor Corp.
 */

#include <linux/device.h>
#include <linux/fs.h>
#include <linux/init.h>
#include <linux/io.h>
#include <linux/interrupt.h>
#include <linux/printk.h>
#include <linux/module.h>
#include <linux/of.h>
#include <linux/of_address.h>
#include <linux/of_irq.h>
#include <linux/of_platform.h>
#include <linux/platform_device.h>
#include <linux/slab.h>
#include <linux/atomic.h>
#include <linux/regmap.h>
#include <linux/mfd/syscon.h>

#include "autctl.h"

/* Interrupt register, under SB2 */
#define CPU0_INT			0xA80
#define CPU0_INT_EN			0xA84
#define CPU0_INT_ST			0xA88

#define INT_SP				(1 << 3)
#define INT_SP_EN			(1 << 3)
#define INT_PS_ST			(1 << 3)

/* Status dummy-register offset, under SB2 */
#define AUT_DUMMY_BOOTINFO_CLUSTER	0x588

/* Status dummy-register offset, under SB2_PMU */
#define AUT_DUMMY_NWC_INT_PCPU		0x470
#define AUT_DUMMY_PCPU_INT_NWC		0x478

/* Remote processor state */
#define AUT_PROC_UNINITED			0x00000000
#define AUT_PROC_NORMAL				0x00001111
#define AUT_PROC_REBOOTING			0x00002222

/* Interrupt reason - to pcpu */
#define AUT_NOTIFY_UNDEFINED			0x00000000
#define AUT_NOTIFY_DRV_READY			0x90110000
#define AUT_NOTIFY_BOOT_COMPLETE		0x10120002
#define AUT_NOTIFY_RESET_AND_RELOAD		0x10111011
#define AUT_NOTIFY_RELOAD_DONE			0x10300020
#define AUT_NOTIFY_RESET_ONLY			0x10001001

/* Interrupt reason - from pcpu */
#define AUT_INT_UNDEFINED			0x00000000
#define AUT_INT_STATE_UPDATE			0x10140004
#define AUT_INT_STATE_UPDATE_AND_RELOAD		0x10141014

struct proc_stat_int_str_t {
	u32 stat;
	char str[PART_NAME_LEN];
};

struct proc_stat_int_str_t proc_stat_str[] = {
	{AUT_PROC_UNINITED, "uninited"},
	{AUT_PROC_NORMAL, "normal"},
	{AUT_PROC_REBOOTING, "rebooting"},
};

struct proc_stat_int_str_t proc_int_out_cmd_str[] = {
	{AUT_NOTIFY_UNDEFINED, "undefine"},
	{AUT_NOTIFY_DRV_READY, "driver_ready"},
	{AUT_NOTIFY_BOOT_COMPLETE, "ivi_complete"},
	{AUT_NOTIFY_RESET_AND_RELOAD, "ivi_reset"},
	{AUT_NOTIFY_RELOAD_DONE, "clus_reload_done"},
};

struct proc_stat_int_str_t proc_int_in_cmd_str[] = {
	{AUT_INT_UNDEFINED, "undefine"},
	{AUT_INT_STATE_UPDATE, "clus_update"}, //
	{AUT_INT_STATE_UPDATE, "clus_reload"}, //
};

/* fire IRQ form scpu to pcpu */
static int pcpu_fire_irq(struct autctl_device *autctl)
{
	regmap_write(autctl->sb2_base, CPU0_INT, INT_SP | 1);
	return 0;
}

static void pcpu_irq_enable(struct autctl_device *autctl)
{
	regmap_write(autctl->sb2_base, CPU0_INT_EN, INT_SP_EN | 1);
}

static void pcpu_irq_disable(struct autctl_device *autctl)
{
	regmap_write(autctl->sb2_base, CPU0_INT_EN, INT_SP_EN);
}

/* pending IRQ generated by pcpu */
static int pcpu_generate_irq_pending(struct autctl_device *autctl)
{
	unsigned int stat;
	regmap_read(autctl->sb2_base, CPU0_INT_ST, &stat);
	return !!(stat & INT_PS_ST);
}

static void pcpu_generate_irq_clr(struct autctl_device *autctl)
{
	regmap_write(autctl->sb2_base, CPU0_INT_ST, INT_PS_ST);
}

static int cluster_proc_get(struct autctl_device *autctl, u32 *val)
{
	regmap_read(autctl->sb2_base, AUT_DUMMY_BOOTINFO_CLUSTER, val);
	return 0;
}

/* notify from scpu->pcpu */
static int pcpu_notify_get(struct autctl_device *autctl, u32 *val)
{
	regmap_read(autctl->sb2_pmu_base, AUT_DUMMY_NWC_INT_PCPU, val);
	return 0;
}

static int pcpu_notify_set(struct autctl_device *autctl, u32 val)
{
	regmap_write(autctl->sb2_pmu_base, AUT_DUMMY_NWC_INT_PCPU, val);
	return 0;
}

/* interrupt from pcpu->scpu */
static int pcpu_int_get(struct autctl_device *autctl, u32 *val)
{
	regmap_read(autctl->sb2_pmu_base, AUT_DUMMY_PCPU_INT_NWC, val);
	return 0;
}

static int pcpu_int_set(struct autctl_device *autctl, u32 val)
{
	regmap_write(autctl->sb2_pmu_base, AUT_DUMMY_PCPU_INT_NWC, val);
	return 0;
}

static ssize_t pcpu_store(struct device *dev, struct device_attribute *attr,
			  const char *buf, size_t count)
{
	struct autctl_device *autctl = dev_get_drvdata(dev);
	char *p;
	int i, len;

	p = memchr(buf, '\n', count);
	len = p ? p - buf : count;

	for (i = 0; i < ARRAY_SIZE(proc_int_out_cmd_str); i++)
		if (!strncmp(buf, proc_int_out_cmd_str[i].str, len))
			break;

	if (i == ARRAY_SIZE(proc_int_out_cmd_str))
		return -EINVAL;

	pcpu_notify_set(autctl, proc_int_out_cmd_str[i].stat);
	pcpu_fire_irq(autctl);

	return count;
}

static ssize_t pcpu_show(struct device *dev, struct device_attribute *attr,
			 char *buf)
{
	struct autctl_device *autctl = dev_get_drvdata(dev);
	int i;
	u32 stat;

	pcpu_notify_get(autctl, &stat);

	buf[0] = '\0';

	for (i = 0; i < ARRAY_SIZE(proc_int_out_cmd_str); i++) {
		bool match = stat == proc_int_out_cmd_str[i].stat;
		if (match)
			strncat(buf, "[", 1);
		strncat(buf, proc_int_out_cmd_str[i].str, ARRAY_SIZE(proc_int_out_cmd_str[i].str));
		if (match)
			strncat(buf, "]", 1);
		strncat(buf, " ", 1);
	}

	strncat(buf, "\n", 1);

	return strnlen(buf, PAGE_SIZE);
}
DEVICE_ATTR_RW(pcpu);

static ssize_t pcpu_int_show(struct device *dev, struct device_attribute *attr,
			    char *buf)
{
	struct autctl_device *autctl = dev_get_drvdata(dev);
	int i;
	u32 stat;
	char *stat_str;

	pcpu_int_get(autctl, &stat);

	for (i = 0; i < ARRAY_SIZE(proc_int_in_cmd_str); i++)
		if (proc_int_in_cmd_str[i].stat == stat)
			break;

	if (i == ARRAY_SIZE(proc_int_in_cmd_str))
		stat_str = "BUG - invalid value";
	else
		stat_str = proc_int_in_cmd_str[i].str;

	pcpu_int_set(autctl, AUT_INT_UNDEFINED);

	return snprintf(buf, PAGE_SIZE, "%s\n", stat_str);
}
DEVICE_ATTR_RO(pcpu_int);

static ssize_t cluster_show(struct device *dev, struct device_attribute *attr,
			    char *buf)
{
	struct autctl_device *autctl = dev_get_drvdata(dev);
	int i;
	u32 stat;
	char *stat_str;

	cluster_proc_get(autctl, &stat);

	for (i = 0; i < ARRAY_SIZE(proc_stat_str); i++)
		if (proc_stat_str[i].stat == stat)
			break;

	if (i == ARRAY_SIZE(proc_stat_str))
		stat_str = "BUG - invalid value";
	else
		stat_str = proc_stat_str[i].str;

	return snprintf(buf, PAGE_SIZE, "%s\n", stat_str);
}
DEVICE_ATTR_RO(cluster);

static ssize_t cluster_reload_store(struct device *dev, struct device_attribute *attr,
			  const char *buf, size_t count)
{
	struct autctl_device *autctl = dev_get_drvdata(dev);
	char *p;
	int len;
	int ret;

	p = memchr(buf, '\n', count);
	len = p ? p - buf : count;

	if (!autctl->part_valid)
		return -ENOENT;

	if (strncmp(buf, "reload", len))
		return -EINVAL;

	ret = rtk_aut_load_cluster(autctl);
	if (ret < 0) {
		dev_err(autctl->dev, "cluster reload FAIL!!\n");
		return ret;
	}

	return count;
}

static ssize_t cluster_reload_show(struct device *dev, struct device_attribute *attr,
			 char *buf)
{
	struct autctl_device *autctl = dev_get_drvdata(dev);

	buf[0] = '\0';

	if (autctl->part_valid)
		snprintf(buf, PART_NAME_LEN * 2, "part:%s\n", autctl->clus_part);
	else
		strcat(buf, "INVALID\n");

	return strnlen(buf, PAGE_SIZE);
}
DEVICE_ATTR_RW(cluster_reload);

static struct attribute *autctl_attrs[] = {
	&dev_attr_cluster.attr,
	&dev_attr_cluster_reload.attr,
	&dev_attr_pcpu.attr,
	&dev_attr_pcpu_int.attr,
	NULL
};

static struct attribute_group autctl_attr_group = {
	.name = "autctl",
	.attrs = autctl_attrs,
};

static irqreturn_t autctl_int_handler_thread(int irq, void *id)
{
	struct platform_device *pdev = id;
	struct device *dev = &pdev->dev;
	struct autctl_device *autctl = dev_get_drvdata(dev);
	u32 stat;
	int i;
	char *envp[2] = { };

	cluster_proc_get(autctl, &stat);

	for (i = 0; i < ARRAY_SIZE(proc_stat_str); i++)
		if (proc_stat_str[i].stat == stat)
			break;

	if (i == ARRAY_SIZE(proc_stat_str))
		BUG();

	dev_dbg(dev, "%s cluster %s\n", __func__, proc_stat_str[i].str);

	envp[0] = proc_stat_str[i].str;
	kobject_uevent_env(&dev->kobj, KOBJ_CHANGE, envp);

	return IRQ_HANDLED;
}

static irqreturn_t autctl_int_handler(int irq, void *id)
{
	struct platform_device *pdev = id;
	struct device *dev = &pdev->dev;
	struct autctl_device *autctl = dev_get_drvdata(dev);

	if (!pcpu_generate_irq_pending(autctl))
		return IRQ_NONE;
	pcpu_generate_irq_clr(autctl);

	return IRQ_WAKE_THREAD;
}

static int autctl_probe(struct platform_device *pdev)
{
	struct device *dev = &pdev->dev;
	struct device_node *np = dev->of_node;
	struct autctl_device *autctl;
	int ret = 0;

	autctl = devm_kzalloc(dev, sizeof(*autctl), GFP_KERNEL);
	if (!autctl)
		return -ENOMEM;
	autctl->dev = dev;

	autctl->sb2_base = syscon_regmap_lookup_by_phandle(np, "realtek,sb2");
	if (IS_ERR_OR_NULL(autctl->sb2_base)) {
		dev_err(dev, "no sb2 base found\n");
		return -ENODEV;
	}

	autctl->sb2_pmu_base = syscon_regmap_lookup_by_phandle(np, "realtek,sb2-pmu");
	if (IS_ERR_OR_NULL(autctl->sb2_pmu_base)) {
		dev_err(dev, "no sb2_pmu base found\n");
		return -ENODEV;
	}

	ret = sysfs_create_group(&dev->kobj, &autctl_attr_group);
	if (ret) {
		dev_err(dev, "failed to create sysfs group: %d\n", ret);
		return ret;
	}

	platform_set_drvdata(pdev, autctl);

	if (of_property_read_string(np, "cluster-partition", &autctl->clus_part)) {
		dev_info(dev, "cluster partition not valid\n");
		autctl->part_valid = false;
	} else
		autctl->part_valid = true;

	autctl->irq = irq_of_parse_and_map(np, 0);
	ret = devm_request_threaded_irq(dev, autctl->irq, autctl_int_handler, autctl_int_handler_thread,
					IRQF_SHARED, dev_name(dev), pdev);
	if (ret) {
		dev_err(dev, "request irq fail\n");
		sysfs_remove_group(&dev->kobj, &autctl_attr_group);
		return ret;
	}
	pcpu_irq_enable(autctl);

	return 0;
}

static int autctl_remove(struct platform_device *pdev)
{
	struct autctl_device *autctl = platform_get_drvdata(pdev);

	pcpu_irq_disable(autctl);
	platform_set_drvdata(pdev, NULL);
	sysfs_remove_group(&pdev->dev.kobj, &autctl_attr_group);
	return 0;
}

static const struct of_device_id autctl_match[] = {
	{.compatible = "realtek,autctl"},
	{}
};
MODULE_DEVICE_TABLE(of, autctl_match);

static struct platform_driver autctl_driver = {
	.probe  = autctl_probe,
	.remove = autctl_remove,
	.driver = {
		.owner = THIS_MODULE,
		.name = "rtk-autctl",
		.of_match_table = of_match_ptr(autctl_match),
	},
};
module_platform_driver(autctl_driver);

MODULE_DESCRIPTION("Realtek Automotive Control driver");
MODULE_LICENSE("GPL");
MODULE_ALIAS("platform:rtk-autctl");
