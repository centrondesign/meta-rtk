From 10be1f75e023201c21f4e1ccca5e723441ee50be Mon Sep 17 00:00:00 2001
From: carolhsu <carolhsu@realtek.com>
Date: Tue, 30 Sep 2025 08:25:45 +0000
Subject: [PATCH] 0001-0930-2

---
 sound/soc/realtek/Kconfig              |    9 +
 sound/soc/realtek/Makefile             |   12 +
 sound/soc/realtek/rtk-afe-common.h     |  198 ++++
 sound/soc/realtek/rtk-afe-platdrv.c    | 1336 ++++++++++++++++++++++++
 sound/soc/realtek/rtk-dai-aio.c        |  333 ++++++
 sound/soc/realtek/rtk-dai-i2s.c        |  196 ++++
 sound/soc/realtek/rtk-hifi-machine.c   |  245 ++---
 sound/soc/realtek/rtk-hifi-rpc.c       |  471 +++++++++
 sound/soc/realtek/rtk-hifi-rpc.h       |  507 +++++++++
 sound/soc/realtek/rtk-hifi-rt5650-mc.c |  599 +++++++++++
 10 files changed, 3759 insertions(+), 147 deletions(-)
 create mode 100644 sound/soc/realtek/rtk-afe-common.h
 create mode 100644 sound/soc/realtek/rtk-afe-platdrv.c
 create mode 100644 sound/soc/realtek/rtk-dai-aio.c
 create mode 100644 sound/soc/realtek/rtk-dai-i2s.c
 create mode 100644 sound/soc/realtek/rtk-hifi-rpc.c
 create mode 100644 sound/soc/realtek/rtk-hifi-rpc.h
 create mode 100644 sound/soc/realtek/rtk-hifi-rt5650-mc.c

diff --git a/sound/soc/realtek/Kconfig b/sound/soc/realtek/Kconfig
index ecdbdc5b8119..c23d758d1f40 100644
--- a/sound/soc/realtek/Kconfig
+++ b/sound/soc/realtek/Kconfig
@@ -41,5 +41,14 @@ config SND_SOC_REALTEK_FL3236
 
 config SND_SOC_RTK_HIFI_MACHINE
 	tristate "Realtek hifi asoc machine Driver"
+	default n
+
+config SND_SOC_RTK_HIFI_RT5650_MACHINE
+	tristate "Realtek hifi with rt5650 codec asoc machine Driver"
 	select SND_SOC_RT5645
 	default n
+
+config SND_SOC_RTK_PLATFORM
+	tristate "Realtek asoc platform Driver"
+	select SND_HWDEP
+	default n
diff --git a/sound/soc/realtek/Makefile b/sound/soc/realtek/Makefile
index 70103c53a9a7..5d093daef380 100644
--- a/sound/soc/realtek/Makefile
+++ b/sound/soc/realtek/Makefile
@@ -6,4 +6,16 @@ obj-$(CONFIG_SND_SOC_REALTEK) += aio_ctrl/
 snd-soc-rtk-hifi-objs := \
        rtk-hifi-machine.o \
 
+snd-soc-rtk-hifi-rt5650-objs := \
+	rtk-hifi-rt5650-mc.o \
+
+# platform driver
+snd-soc-rtk-afe-objs := \
+	rtk-hifi-rpc.o \
+	rtk-dai-i2s.o \
+	rtk-dai-aio.o \
+	rtk-afe-platdrv.o
+
 obj-$(CONFIG_SND_SOC_RTK_HIFI_MACHINE) += snd-soc-rtk-hifi.o
+obj-$(CONFIG_SND_SOC_RTK_HIFI_RT5650_MACHINE) += snd-soc-rtk-hifi-rt5650.o
+obj-$(CONFIG_SND_SOC_RTK_PLATFORM) += snd-soc-rtk-afe.o
diff --git a/sound/soc/realtek/rtk-afe-common.h b/sound/soc/realtek/rtk-afe-common.h
new file mode 100644
index 000000000000..4ca584a5825e
--- /dev/null
+++ b/sound/soc/realtek/rtk-afe-common.h
@@ -0,0 +1,198 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * rtk-afe-common.h  --  Realtek audio driver definitions
+ *
+ * Copyright (c) 2024 RealTek Inc.
+ * Author: Simon Hsu <simon_hsu@realtek.com>
+ */
+
+#ifndef RTK_AFE_COMMON_H_
+#define RTK_AFE_COMMON_H_
+
+#define AFE_PCM_NAME "rtk-afe-pcm"
+
+#include <sound/soc.h>
+#include <soc/realtek/memory.h>
+#include <soc/realtek/rtk_media_heap.h>
+#include "rtk-hifi-rpc.h"
+
+#define RTK_PCM_INFO	SNDRV_PCM_INFO_INTERLEAVED | \
+			SNDRV_PCM_INFO_NONINTERLEAVED | \
+			SNDRV_PCM_INFO_RESUME | \
+			SNDRV_PCM_INFO_MMAP | \
+			SNDRV_PCM_INFO_MMAP_VALID | \
+			SNDRV_PCM_INFO_PAUSE
+
+#define RTK_PCM_RATES	SNDRV_PCM_RATE_8000_48000 |\
+			SNDRV_PCM_RATE_88200 |\
+			SNDRV_PCM_RATE_96000 |\
+			SNDRV_PCM_RATE_176400 |\
+			SNDRV_PCM_RATE_192000
+
+#define RTK_PCM_FORMATS SNDRV_PCM_FMTBIT_S8 | \
+			SNDRV_PCM_FMTBIT_S16_LE | \
+			SNDRV_PCM_FMTBIT_S24_LE | \
+			SNDRV_PCM_FMTBIT_S24_3LE
+
+#define RTK_PCM_RATE_MIN		16000
+#define RTK_PCM_RATE_MAX		192000
+#define RTK_PCM_CHANNELS_MIN		1
+#define RTK_PCM_CHANNELS_MAX		8
+#define RTK_PCM_MAX_BUFFER_SIZE		(192 * 1024)
+#define RTK_PCM_MIN_PERIOD_SIZE		1024
+#define RTK_PCM_MAX_PERIOD_SIZE		(24 * 1024)
+#define RTK_PCM_PERIODS_MIN		4
+#define RTK_PCM_PERIODS_MAX		1024
+#define RTK_PCM_FIFO_SIZE		32
+
+#define RTK_HIFI_FLAGS	RTK_FLAG_NONCACHED | RTK_FLAG_SCPUACC | RTK_FLAG_HIFIACC
+#define RTK_ACPU_FLAGS	RTK_FLAG_NONCACHED | RTK_FLAG_SCPUACC | RTK_FLAG_ACPUACC
+#define RTK_SECURE_FLAGS \
+	RTK_FLAG_PROTECTED_V2_AO_POOL | RTK_FLAG_SCPUACC | RTK_FLAG_ACPUACC
+
+#define RTK_ENC_AI_BUFFER_SIZE		(32 * 1024)
+
+#define RTK_AUDIO_OUT_I2S_2_CHANNEL	0
+#define RTK_AUDIO_OUT_I2S_8_CHANNEL	1
+
+#define RTK_AUDIO_OUT_I2S_MODE_MASTER	0
+#define RTK_AUDIO_OUT_I2S_MODE_SLAVE	1
+
+struct rtk_pcm_mmap_fd {
+	int dir;
+	int fd;
+	int size;
+	int actual_size;
+};
+
+struct audio_mixing_index {
+	int enable;
+	int mixing_channel[32];
+	int reserved[15];
+};
+
+#define SNDRV_PCM_IOCTL_MMAP_DATA_FD _IOWR('A', 0xE4, struct rtk_pcm_mmap_fd)
+#define SNDRV_PCM_IOCTL_MIX_IDX_SET _IOW('A', 0xE7, struct audio_mixing_index)
+#define SNDRV_PCM_IOCTL_GET_LATENCY  _IOR('A', 0xF0, int)
+
+enum {
+	RTK_DAI_START,
+	RTK_DAI_MEMIF_START = RTK_DAI_START,
+	RTK_DAI_MEMIF_DL1 = RTK_DAI_MEMIF_START,
+	RTK_DAI_MEMIF_DL2,
+	RTK_DAI_MEMIF_DL3,
+	RTK_DAI_MEMIF_UL1,
+	RTK_DAI_MEMIF_UL2,
+	RTK_DAI_MEMIF_UL3,
+	RTK_DAI_MEMIF_END,
+	RTK_DAI_MEMIF_NUM = (RTK_DAI_MEMIF_END - RTK_DAI_MEMIF_START),
+	RTK_DAI_I2S_START = RTK_DAI_MEMIF_END,
+	RTK_DAI_I2S_0 = RTK_DAI_I2S_START,
+	RTK_DAI_I2S_1,
+	RTK_DAI_I2S_END,
+	RTK_DAI_AIO_START = RTK_DAI_I2S_END,
+	RTK_DAI_AO_START = RTK_DAI_AIO_START,
+	RTK_DAI_AUDIO_OUT0 = RTK_DAI_AIO_START,
+	RTK_DAI_AUDIO_OUT1,
+	RTK_DAI_AO_END,
+	RTK_DAI_AI_START = RTK_DAI_AO_END,
+	RTK_DAI_I2S0_LOOPBACK,
+	RTK_DAI_AI_END,
+	RTK_DAI_AIO_END = RTK_DAI_AI_END,
+	RTK_DAI_END = RTK_DAI_AIO_END,
+	RTK_DAI_NUM = (RTK_DAI_END - RTK_DAI_START),
+};
+
+struct audio_ringbuf_ptr {
+	unsigned long base;
+	unsigned long limit;
+	unsigned long cp;
+	unsigned long rp;
+	unsigned long wp;
+};
+
+struct rtk_snd_ringbuf {
+	struct rtk_afe_priv *afe;
+	struct snd_dma_buffer *dmab;
+	struct kref ref;
+	int bufnum;
+
+	/* for ringbuf header */
+	dma_addr_t paddr;
+	void *vaddr;
+	int hdr_size;
+	struct ringbuf_header_ptrs *hdr_ptrs;
+	struct rpc_ringbuffer_header ring_header;
+};
+
+struct rtk_afe_memif {
+	struct rtk_snd_ringbuf *ringbuf;
+
+	struct hrtimer timer;
+	enum hrtimer_restart stat;
+	ktime_t ktime;
+	struct snd_pcm_substream *substream;
+
+	unsigned int pin;
+
+	snd_pcm_uframes_t hw_ptr;
+	snd_pcm_uframes_t prehw_ptr;
+	snd_pcm_uframes_t total_read;
+	snd_pcm_uframes_t total_write;
+};
+
+struct rtk_pcm_runtime_priv {
+	struct rtk_afe_memif *memif;
+	int ao_id;
+	int ai_id;
+};
+
+struct rtk_afe_data {
+	unsigned int ao_num;
+	unsigned int ao_bitmap_mask;
+	unsigned int i2s_out_ch;
+	unsigned int lb_secure;
+};
+
+struct rtk_afe_priv {
+	struct device *dev;
+	struct rtk_rpc_priv rpc_priv;
+	struct rtk_afe_memif *memif;
+
+	struct list_head sub_dais;
+	struct snd_soc_dai_driver *dai_drivers;
+	unsigned int num_dai_drivers;
+	void *dai_priv[RTK_DAI_NUM];
+
+	const struct snd_pcm_hardware *rtk_afe_hardware;
+	const struct rtk_afe_data *data;
+
+	bool fw_mem_cfg;
+};
+
+struct rtk_afe_dai {
+	struct snd_soc_dai_driver *dai_drivers;
+	unsigned int num_dai_drivers;
+
+	const struct snd_kcontrol_new *controls;
+	unsigned int num_controls;
+	const struct snd_soc_dapm_widget *dapm_widgets;
+	unsigned int num_dapm_widgets;
+	const struct snd_soc_dapm_route *dapm_routes;
+	unsigned int num_dapm_routes;
+
+	struct list_head list;
+};
+
+void rtk_snd_free_ringbuf(struct rtk_snd_ringbuf **ringbuf);
+int rtk_snd_prepare_ringbuf(struct rtk_afe_priv *afe,
+			    struct snd_dma_buffer *dma_buffer,
+			    size_t size, size_t bufnum,
+			    struct rtk_snd_ringbuf **ringbuf,
+			    struct rpc_ringbuffer_header *hdr,
+			    unsigned long heap_flags);
+
+int rtk_dai_i2s_register(struct rtk_afe_priv *afe);
+int rtk_dai_aio_register(struct rtk_afe_priv *afe);
+
+#endif
diff --git a/sound/soc/realtek/rtk-afe-platdrv.c b/sound/soc/realtek/rtk-afe-platdrv.c
new file mode 100644
index 000000000000..ad94c5c58f04
--- /dev/null
+++ b/sound/soc/realtek/rtk-afe-platdrv.c
@@ -0,0 +1,1336 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * rtk-afe-platform-driver.c  --  Realtek afe platform driver
+ *
+ * Copyright (c) 2024 RealTek Inc.
+ * Author: Simon Hsu <simon_hsu@realtek.com>
+ */
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/dma-buf.h>
+#include <linux/dma-map-ops.h>
+#include <sound/hwdep.h>
+
+#include <soc/realtek/rtk_refclk.h>
+
+#include "rtk-afe-common.h"
+
+#define for_each_pcm_substream(pcm, str, subs) \
+	for ((str) = 0; (str) < 2; (str)++) \
+		for ((subs) = (pcm)->streams[str].substream; (subs); \
+		     (subs) = (subs)->next)
+
+static const struct rtk_afe_data stark_afe =
+{
+	.ao_num = 1,
+	.ao_bitmap_mask = 0x1F,
+	.i2s_out_ch = 2,
+	.lb_secure = 0,
+};
+
+static const struct rtk_afe_data morbius_afe =
+{
+	.ao_num = 1,
+	.ao_bitmap_mask = 0x1F,
+	.i2s_out_ch = 2,
+	.lb_secure = 0,
+};
+
+static const struct rtk_afe_data kent_afe =
+{
+	.ao_num = 1,
+	.ao_bitmap_mask = 0xFFF,
+	.i2s_out_ch = 8,
+	.lb_secure = 1,
+};
+
+static const struct rtk_afe_data kent_2ao_afe = 
+{
+	.ao_num = 2,
+	.ao_bitmap_mask = 0xFFF,
+	.i2s_out_ch = 8,
+	.lb_secure = 1,
+};
+
+static const struct snd_pcm_hardware rtk_afe_hardware = {
+	.info = RTK_PCM_INFO,
+	.formats = RTK_PCM_FORMATS,
+	.period_bytes_min = RTK_PCM_MIN_PERIOD_SIZE,
+	.period_bytes_max = RTK_PCM_MAX_PERIOD_SIZE,
+	.periods_min = RTK_PCM_PERIODS_MIN,
+	.periods_max = RTK_PCM_PERIODS_MAX,
+	.buffer_bytes_max = RTK_PCM_MAX_BUFFER_SIZE,
+	.fifo_size = RTK_PCM_FIFO_SIZE,
+};
+
+static void ring1_to_ring2_general(struct audio_ringbuf_ptr *ring1,
+				   struct audio_ringbuf_ptr *ring2,
+				   long size)
+{
+	if (ring1->rp + size <= ring1->limit) {
+		if (ring2->wp + size <= ring2->limit) {
+			memcpy((char *)ring2->wp, (char *)ring1->rp, size);
+		} else {
+			int i = ring2->limit - ring2->wp;
+
+			memcpy((char *)ring2->wp, (char *)ring1->rp, i);
+			memcpy((char *)ring2->base, (char *)(ring1->rp + i), size - i);
+		}
+	} else {
+		if (ring2->wp + size <= ring2->limit) {
+			int i = ring1->limit - ring1->rp;
+
+			memcpy((char *)ring2->wp, (char *)ring1->rp, i);
+			memcpy((char *)(ring2->wp + i), (char *)(ring1->base), size - i);
+		} else {
+			int i, j;
+
+			i = ring1->limit - ring1->rp;
+			j = ring2->limit - ring2->wp;
+
+			if (j <= i) {
+				memcpy((char *)ring2->wp, (char *)ring1->rp, j);
+				memcpy((char *)ring2->base, (char *)(ring1->rp + j), i - j);
+				memcpy((char *)(ring2->base + i - j),
+				       (char *)(ring1->base), size - i);
+			} else {
+				memcpy((char *)ring2->wp, (char *)ring1->rp, i);
+				memcpy((char *)(ring2->wp + i), (char *)ring1->base, j - i);
+				memcpy((char *)ring2->base,
+				       (char *)(ring1->base + j - i), size - j);
+			}
+		}
+	}
+
+	ring1->rp += size;
+	if (ring1->rp >= ring1->limit)
+		ring1->rp = ring1->base + (ring1->rp - ring1->limit);
+
+	ring2->wp += size;
+	if (ring2->wp >= ring2->limit)
+		ring2->wp = ring2->base + (ring2->wp - ring2->limit);
+}
+
+static void snd_card_capture_lpcm_copy(struct snd_pcm_runtime *runtime,
+				       long period_count,
+				       unsigned int total_write,
+				       unsigned int *lpcm_base,
+				       struct ringbuf_header_ptrs *header)
+{
+	snd_pcm_uframes_t frame_size = period_count * runtime->period_size;
+	snd_pcm_uframes_t dma_wp = total_write % runtime->buffer_size;
+	struct audio_ringbuf_ptr src_ring, dst_ring;
+
+	src_ring.base = (unsigned long)lpcm_base;
+	src_ring.limit = (unsigned long)(src_ring.base + *header->p_size);
+	src_ring.rp = src_ring.base
+		+ (unsigned long)(*header->p_read_ptr - *header->p_begin_addr);
+
+	dst_ring.base = (unsigned long)runtime->dma_area;
+	dst_ring.limit = (unsigned long)(runtime->dma_area +
+					 frames_to_bytes(runtime, runtime->buffer_size));
+	dst_ring.wp = (unsigned long)(runtime->dma_area + frames_to_bytes(runtime, dma_wp));
+
+	ring1_to_ring2_general(&src_ring, &dst_ring, frames_to_bytes(runtime, frame_size));
+}
+
+static unsigned long ring_valid_data(unsigned long ring_base,
+				     unsigned long ring_limit,
+				     unsigned long ring_rp,
+				     unsigned long ring_wp)
+{
+	if (ring_wp >= ring_rp)
+		return (ring_wp - ring_rp);
+	else
+		return (ring_limit - ring_base) - (ring_rp - ring_wp);
+}
+
+static unsigned long ring_add(unsigned long ring_base,
+			      unsigned long ring_limit,
+			      unsigned long ptr,
+			      unsigned int bytes)
+{
+	ptr += bytes;
+	if (ptr >= ring_limit)
+		ptr = ring_base + (ptr - ring_limit);
+
+	return ptr;
+}
+#if 0
+static unsigned long ring_minus(unsigned long ring_base,
+				unsigned long ring_limit,
+				unsigned long ptr,
+				int bytes)
+{
+	ptr -= bytes;
+	if (ptr < ring_base)
+		ptr = ring_limit - (ring_base - ptr);
+
+	return ptr;
+}
+#endif
+static unsigned long valid_free_size(unsigned long base,
+				     unsigned long limit,
+				     unsigned long rp,
+				     unsigned long wp)
+{
+	/* -1 to avoid confusing full or empty */
+	return (limit - base) - ring_valid_data(base, limit, rp, wp) - 1;
+}
+
+static int rtk_snd_alloc(struct device *dev, size_t size,
+			 void *phy, void **virt, unsigned long heap_flags)
+{
+	mutex_lock(&dev->mutex);
+	rheap_setup_dma_pools(dev, "rtk_media_heap", heap_flags, __func__);
+	*virt = dma_alloc_coherent(dev, size, phy, GFP_KERNEL);
+	mutex_unlock(&dev->mutex);
+	if (!*virt) {
+		dev_err(dev, "[%s] alloc fail\n", __func__);
+		return -ENOMEM;
+	}
+	return 0;
+}
+
+static void rtk_snd_ringbuf_destroy(struct kref *kref)
+{
+	struct rtk_snd_ringbuf *buf =
+			container_of(kref, struct rtk_snd_ringbuf, ref);
+
+	rtk_snd_free_ringbuf(&buf);
+}
+
+static enum hrtimer_restart rtk_afe_play_timer_func(struct hrtimer *timer)
+{
+	struct rtk_afe_memif *memif =
+		container_of(timer, struct rtk_afe_memif, timer);
+
+	if (memif->stat == HRTIMER_RESTART) {
+		snd_pcm_period_elapsed(memif->substream);
+		hrtimer_forward_now(timer, memif->ktime);
+		return HRTIMER_RESTART;
+	}
+
+	return HRTIMER_NORESTART;
+}
+
+static enum hrtimer_restart rtk_afe_cap_timer_func(struct hrtimer *timer)
+{
+	struct rtk_afe_memif *memif =
+		container_of(timer, struct rtk_afe_memif, timer);
+	struct snd_pcm_substream *substream = memif->substream;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct ringbuf_header_ptrs *header = memif->ringbuf->hdr_ptrs;
+	snd_pcm_uframes_t data_frame;
+	unsigned long data_size, free_size;
+	unsigned int period_count = 0, free_period;
+
+	if (memif->stat == HRTIMER_RESTART) {
+		data_size = ring_valid_data(*header->p_begin_addr,
+					*header->p_begin_addr + *header->p_size,
+					*header->p_read_ptr,
+					*header->p_write_ptr);
+		data_frame = bytes_to_frames(runtime, data_size);
+		if (data_frame >= runtime->period_size) {
+			period_count = data_frame / runtime->period_size;
+			if (period_count == runtime->periods)
+				period_count--;
+
+			/* check overflow */
+			free_size = runtime->buffer_size - ring_valid_data(0,
+					(unsigned long)runtime->boundary,
+					(unsigned long)runtime->control->appl_ptr,
+					(unsigned long)runtime->status->hw_ptr);
+			free_period = free_size / runtime->period_size;
+			period_count = min(period_count, free_period);
+			if (period_count == 0)
+				goto SET_TIMER;
+
+			snd_card_capture_lpcm_copy(runtime, period_count,
+						   memif->total_write,
+						   (unsigned int *)memif->ringbuf->dmab->area,
+						   memif->ringbuf->hdr_ptrs);
+
+			*header->p_read_ptr = ring_add(*header->p_begin_addr,
+						*header->p_begin_addr + *header->p_size,
+						*header->p_read_ptr,
+				 		frames_to_bytes(runtime,
+						runtime->period_size * period_count));
+			memif->total_write += period_count * runtime->period_size;
+			snd_pcm_period_elapsed(substream);
+		}
+SET_TIMER:
+		/* Set up the next time */
+		hrtimer_forward_now(timer, memif->ktime);
+		return HRTIMER_RESTART;
+	}
+
+	return HRTIMER_NORESTART;
+}
+
+void rtk_snd_free_ringbuf(struct rtk_snd_ringbuf **ringbuf)
+{
+	struct rtk_afe_priv *afe;
+	struct rpc_ringbuffer_header hdr = {0};
+	struct snd_dma_buffer *dmab;
+	dma_addr_t paddr;
+	void *vaddr;
+	size_t size;
+	int i;
+
+	if (*ringbuf == NULL)
+		return;
+
+	afe = (*ringbuf)->afe;
+	/* uninit ringbuffer */
+	hdr.instance_id = (*ringbuf)->ring_header.instance_id;
+	hdr.pin_id = (*ringbuf)->ring_header.pin_id;
+	if (hdr.instance_id && hdr.pin_id)
+		rpc_init_ringbuffer_header(&afe->rpc_priv, &hdr);
+
+	dev_info(afe->dev, "%s id = 0x%x, pin = 0x%x, number = %d\n",
+		 __func__, hdr.instance_id, hdr.pin_id, (*ringbuf)->bufnum);
+
+	for (i = 0; i < (*ringbuf)->bufnum; i++) {
+		dmab = &(*ringbuf)->dmab[i];
+		vaddr = (void *)dmab->area;
+		if (vaddr) {
+			paddr = dmab->addr;
+			size = dmab->bytes;
+			dma_free_coherent(afe->dev, size, vaddr, paddr);
+		} else {
+			dev_err(afe->dev, "free dmabuf fail %d\n", i);
+		}
+	}
+
+	paddr = (*ringbuf)->paddr;
+	vaddr = (*ringbuf)->vaddr;
+	if (vaddr)
+		dma_free_coherent(afe->dev, SZ_4K, vaddr, paddr);
+
+	if ((*ringbuf)->hdr_ptrs) {
+		kfree((*ringbuf)->hdr_ptrs);
+		(*ringbuf)->hdr_ptrs = NULL;
+	}
+	if ((*ringbuf)->dmab) {
+		kfree((*ringbuf)->dmab);
+		(*ringbuf)->dmab = NULL;
+	}
+	kfree(*ringbuf);
+	*ringbuf = NULL;
+}
+
+int rtk_snd_prepare_ringbuf(struct rtk_afe_priv *afe,
+			    struct snd_dma_buffer *dma_buffer,
+			    size_t size, size_t bufnum,
+			    struct rtk_snd_ringbuf **ringbuf,
+			    struct rpc_ringbuffer_header *hdr,
+			    unsigned long heap_flags)
+{
+	struct rtk_snd_ringbuf *buf;
+	struct snd_dma_buffer *dmab;
+	struct ringbuf_header_ptrs *header;
+	dma_addr_t paddr;
+	void *vaddr;
+	int i, ret = -1, offset;
+
+	if (*ringbuf)
+		rtk_snd_free_ringbuf(ringbuf);
+
+	buf = kzalloc(sizeof(*buf), GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+	buf->afe = afe;
+
+	if (dma_buffer)
+		goto prepare_ringbuf_header;
+
+	dmab = kcalloc(bufnum, sizeof(*dmab), GFP_KERNEL);
+	if (!dmab)
+		goto err_alloc_ringbuf;
+	buf->dmab = dmab;
+
+	for (i = 0; i < bufnum; i++) {
+		ret = rtk_snd_alloc(afe->dev, size, (void *)&paddr, &vaddr,
+				    heap_flags);
+		if (ret)
+			goto err_alloc_ringbuf;
+		dmab[i].addr = paddr;
+		dmab[i].area = vaddr;
+		dmab[i].bytes = size;
+		dmab[i].dev.dev = afe->dev;
+		buf->bufnum ++;
+	}
+
+prepare_ringbuf_header:
+	header = kcalloc(bufnum, sizeof(*header), GFP_KERNEL);
+	if (!header)
+		goto err_alloc_ringbuf;
+	buf->hdr_ptrs = header;
+
+	if (afe->fw_mem_cfg)
+		ret = rtk_snd_alloc(afe->dev, SZ_4K, (void *)&paddr, &vaddr, RTK_ACPU_FLAGS);
+	else
+		ret = rtk_snd_alloc(afe->dev, SZ_4K, (void *)&paddr, &vaddr, RTK_HIFI_FLAGS);
+
+	if (ret)
+		goto err_alloc_ringbuf;
+
+	buf->paddr = paddr;
+	buf->vaddr = vaddr;
+
+	for (i = 0; i < bufnum; i++) {
+		offset = init_ringbuf_header_ptrs(&header[i], vaddr, afe->fw_mem_cfg);
+
+		if (!dma_buffer)
+			*header[i].p_begin_addr = dmab[i].addr;
+		else
+			*header[i].p_begin_addr = dma_buffer->addr;
+		*header[i].p_size = size;
+		*header[i].p_buffer_id = 0;
+		*header[i].p_write_ptr = *header[i].p_begin_addr;
+		*header[i].p_read_ptr = *header[i].p_begin_addr;
+		*header[i].p_num_read_ptr = 1;
+
+		buf->ring_header.ringbuffer_header_list[i] = paddr;
+
+		vaddr = vaddr + offset;
+		paddr = paddr + offset;
+	}
+
+	buf->ring_header.instance_id = hdr->instance_id;
+	buf->ring_header.pin_id = hdr->pin_id;
+	buf->ring_header.read_idx = hdr->read_idx;
+	buf->ring_header.list_size = bufnum;
+	ret = rpc_init_ringbuffer_header(&afe->rpc_priv, &buf->ring_header);
+	if (ret)
+		goto err_alloc_ringbuf;
+
+	dev_info(afe->dev, "%s id = 0x%x, pin = 0x%x, number = %d\n",
+		 __func__, hdr->instance_id, hdr->pin_id, buf->bufnum);
+
+	*ringbuf = buf;
+	return 0;
+
+err_alloc_ringbuf:
+	rtk_snd_free_ringbuf(&buf);
+
+	return ret;
+}
+
+static int rtk_dai_fe_startup(struct snd_pcm_substream *substream,
+			      struct snd_soc_dai *dai)
+{
+	struct rtk_afe_priv *afe = snd_soc_dai_get_drvdata(dai);
+	struct rtk_afe_memif *memif = afe->dai_priv[dai->id];
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int ret;
+
+	snd_pcm_hw_constraint_step(substream->runtime, 0,
+				   SNDRV_PCM_HW_PARAM_BUFFER_BYTES, 16);
+
+	snd_soc_set_runtime_hwparams(substream, afe->rtk_afe_hardware);
+
+	ret = snd_pcm_hw_constraint_integer(runtime,
+					    SNDRV_PCM_HW_PARAM_PERIODS);
+	if (ret < 0) {
+		dev_err(afe->dev, "snd_pcm_hw_constraint_integer failed\n");
+		return ret;
+	}
+
+	hrtimer_init(&memif->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		memif->timer.function = &rtk_afe_play_timer_func;
+	else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+		memif->timer.function = &rtk_afe_cap_timer_func;
+
+	return 0;
+}
+
+static int rtk_dai_fe_hw_free(struct snd_pcm_substream *substream,
+			      struct snd_soc_dai *dai)
+{
+	struct rtk_afe_priv *afe = snd_soc_dai_get_drvdata(dai);
+	struct rtk_afe_memif *memif = afe->dai_priv[dai->id];
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct rtk_pcm_runtime_priv *pcm_priv = runtime->private_data;
+	ktime_t remaining;
+	int ret, configured = 0;
+
+	if (!pcm_priv)
+		return 0;
+
+	remaining = hrtimer_get_remaining(&memif->timer);
+	if (ktime_to_ns(remaining) > 0)
+		ndelay(ktime_to_ns(remaining));
+
+	ret = hrtimer_cancel(&memif->timer);
+	if (ret) {
+		dev_err(afe->dev, "the timer still alive...\n");
+		goto err_send_rpc;
+	}
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		if (memif->pin) {
+			ret = rpc_put_shmem_latency(&afe->rpc_priv, pcm_priv->ao_id,
+						    memif->pin, NULL);
+			if (ret)
+				goto err_send_rpc;
+			ret = rpc_pause_svc(&afe->rpc_priv, (pcm_priv->ao_id | memif->pin));
+			if (ret)
+				goto err_send_rpc;
+			ret = rpc_stop_svc(&afe->rpc_priv, (pcm_priv->ao_id | memif->pin));
+			if (ret)
+				goto err_send_rpc;
+			ret = rpc_put_ao_flash_pin(&afe->rpc_priv, pcm_priv->ao_id, &memif->pin);
+			if (ret)
+				goto err_send_rpc;
+		}
+
+		pcm_priv->memif = NULL;
+
+		if (memif->ringbuf) {
+			snd_pcm_set_runtime_buffer(substream, NULL);
+			kref_put(&memif->ringbuf->ref, rtk_snd_ringbuf_destroy);
+			memif->ringbuf = NULL;
+		}
+	} else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		if (memif->substream)
+			configured = 1;
+		/* todo flow not correct */
+		ret = rpc_destroy_ai_flow(&afe->rpc_priv, pcm_priv->ai_id, configured);
+		if (ret)
+			goto err_send_rpc;
+
+		pcm_priv->ai_id = 0;
+		memif->ringbuf->ring_header.instance_id = 0;
+		memif->ringbuf->ring_header.pin_id = 0;
+
+		rtk_snd_free_ringbuf(&memif->ringbuf);
+	}
+	return 0;
+
+err_send_rpc:
+	return ret;
+}
+
+static int rtk_dai_fe_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params,
+				struct snd_soc_dai *dai)
+{
+	struct rtk_afe_priv *afe = snd_soc_dai_get_drvdata(dai);
+	struct rtk_afe_memif *memif = afe->dai_priv[dai->id];
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct rtk_pcm_runtime_priv *pcm_priv = runtime->private_data;
+	struct rpc_ringbuffer_header ring_header = {0};
+	int ret, pin;
+	size_t size;
+
+	if (!pcm_priv)
+		return -1;
+	if (memif->ringbuf)
+		rtk_dai_fe_hw_free(substream, dai);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		/* get flash pin from fw */
+		ret = rpc_get_ao_flash_pin(&afe->rpc_priv, pcm_priv->ao_id, &pin);
+		if (ret || pin < FLASH_AUDIO_PIN_1 || pin > FLASH_AUDIO_PIN_8) {
+			dev_err(afe->dev, "[%s] flash pin get fail, %d\n", __func__, pin);
+			return -1;
+		}
+		memif->pin = pin;
+
+		/* prepare input ring buffer */
+		ring_header.instance_id = pcm_priv->ao_id;
+		ring_header.pin_id = pin;
+
+		size = params_buffer_bytes(params);
+		ret = rtk_snd_prepare_ringbuf(afe, NULL, size, 1, &memif->ringbuf,
+					      &ring_header, RTK_ACPU_FLAGS);
+		if (ret)
+			goto err_prepare_ringbuf;
+
+		kref_init(&memif->ringbuf->ref);
+
+		pcm_priv->memif = memif;
+		memif->ringbuf->hdr_ptrs->p_latency->sync = 0x23792379;
+
+		snd_pcm_set_runtime_buffer(substream, memif->ringbuf->dmab);
+		runtime->dma_bytes = size;
+	} else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		ring_header.instance_id = pcm_priv->ai_id;
+		ring_header.pin_id = BASE_BS_OUT;
+		ring_header.read_idx = -1;
+		ret = rtk_snd_prepare_ringbuf(afe, NULL, RTK_ENC_AI_BUFFER_SIZE,
+					      1, &memif->ringbuf, &ring_header,
+					      RTK_ACPU_FLAGS);
+		if (ret)
+			goto err_prepare_ringbuf;
+	}
+	return 0;
+
+err_prepare_ringbuf:
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		rpc_put_ao_flash_pin(&afe->rpc_priv, pcm_priv->ao_id, &memif->pin);
+
+	rtk_snd_free_ringbuf(&memif->ringbuf);
+	return ret;
+}
+
+static int rtk_dai_fe_prepare(struct snd_pcm_substream *substream,
+			      struct snd_soc_dai *dai)
+{
+	struct rtk_afe_priv *afe = snd_soc_dai_get_drvdata(dai);
+	struct rtk_afe_memif *memif = afe->dai_priv[dai->id];
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct rtk_pcm_runtime_priv *pcm_priv = runtime->private_data;
+	int ret, pin;
+
+	dev_info(afe->dev, "%s %s:\n", __func__, substream->name);
+	dev_info(afe->dev, "rate %d channel %d format %d\n", runtime->rate, runtime->channels, runtime->format);
+	dev_info(afe->dev, "period_size %ld peroid %d\n", runtime->period_size, runtime->periods);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		memif->ktime = ktime_set(0, (runtime->period_size * 1000) * 1000 /
+					      runtime->rate * 1000);
+		pin = memif->pin;
+
+		ret = rpc_put_shmem_latency(&afe->rpc_priv, pcm_priv->ao_id, pin,
+				(void *)memif->ringbuf->paddr + SHMEM_OFFSET);
+
+		ret = rpc_config_ao(&afe->rpc_priv, pcm_priv->ao_id, pin, runtime);
+		if (ret)
+			goto err_send_rpc;
+		ret = rpc_pause_svc(&afe->rpc_priv, (pcm_priv->ao_id | pin));
+		if (ret)
+			goto err_send_rpc;
+		ret = rpc_run_svc(&afe->rpc_priv, (pcm_priv->ao_id | pin));
+		if (ret)
+			goto err_send_rpc;
+	} else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		memif->ktime = ktime_set(0, (runtime->period_size * 1000) /
+					      runtime->rate * 1000 * 1000);
+
+		ret = rpc_ai_connect_alsa(&afe->rpc_priv, runtime, pcm_priv->ai_id);
+		if (ret)
+			goto err_send_rpc;
+		ret = rpc_pause_svc(&afe->rpc_priv, pcm_priv->ai_id);
+		if (ret)
+			goto err_send_rpc;
+		ret = rpc_run_svc(&afe->rpc_priv, pcm_priv->ai_id);
+		if (ret)
+			goto err_send_rpc;
+	}
+	memif->substream = substream;
+	return 0;
+
+err_send_rpc:
+	return ret;
+}
+
+static int rtk_dai_fe_trigger(struct snd_pcm_substream *substream, int cmd,
+			      struct snd_soc_dai *dai)
+{
+	struct rtk_afe_priv *afe = snd_soc_dai_get_drvdata(dai);
+	struct rtk_afe_memif *memif = afe->dai_priv[dai->id];
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		switch (cmd) {
+		case SNDRV_PCM_TRIGGER_STOP:
+			memif->stat = HRTIMER_NORESTART;
+			hrtimer_try_to_cancel(&memif->timer);
+			break;
+		case SNDRV_PCM_TRIGGER_START:
+			memif->stat = HRTIMER_RESTART;
+			hrtimer_start(&memif->timer, memif->ktime, HRTIMER_MODE_REL);
+			break;
+		}
+	} else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		switch (cmd) {
+		case SNDRV_PCM_TRIGGER_STOP:
+			memif->stat = HRTIMER_NORESTART;
+			hrtimer_try_to_cancel(&memif->timer);
+			break;
+		case SNDRV_PCM_TRIGGER_START:
+			memif->stat = HRTIMER_RESTART;
+			hrtimer_start(&memif->timer, memif->ktime, HRTIMER_MODE_REL);
+			break;
+		}
+	}
+	return 0;
+}
+
+static void rtk_dai_fe_shutdown(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	struct rtk_afe_priv *afe = snd_soc_dai_get_drvdata(dai);
+	struct rtk_afe_memif *memif = afe->dai_priv[dai->id];
+
+	memset(memif, 0, sizeof(*memif));
+}
+
+const struct snd_soc_dai_ops rtk_dai_fe_ops = {
+	.startup	= rtk_dai_fe_startup,
+	.shutdown	= rtk_dai_fe_shutdown,
+	.hw_params	= rtk_dai_fe_hw_params,
+	.hw_free	= rtk_dai_fe_hw_free,
+	.prepare	= rtk_dai_fe_prepare,
+	.trigger	= rtk_dai_fe_trigger,
+};
+
+static const char * const src_sel_mux_text[] = {
+	"i2s", "ao_lb", "dmic",
+};
+
+static SOC_ENUM_SINGLE_DECL(src_sel_mux_enum,
+	SND_SOC_NOPM, 0, src_sel_mux_text);
+
+static const struct snd_kcontrol_new ul1_src_sel_mux =
+	SOC_DAPM_ENUM("UL1 src sel", src_sel_mux_enum);
+static const struct snd_kcontrol_new ul2_src_sel_mux =
+	SOC_DAPM_ENUM("UL2 src sel", src_sel_mux_enum);
+static const struct snd_kcontrol_new ul3_src_sel_mux =
+	SOC_DAPM_ENUM("UL3 src sel", src_sel_mux_enum);
+
+static const struct snd_soc_dapm_widget rtk_dai_memif_widgets[] = {
+	SND_SOC_DAPM_MUX("UL1 Source", SND_SOC_NOPM, 0, 0, &ul1_src_sel_mux),
+	SND_SOC_DAPM_MUX("UL2 Source", SND_SOC_NOPM, 0, 0, &ul2_src_sel_mux),
+	SND_SOC_DAPM_MUX("UL3 Source", SND_SOC_NOPM, 0, 0, &ul3_src_sel_mux),
+};
+
+static const struct snd_soc_dapm_route rtk_dai_memif_routes[] = {
+	{"UL1", NULL, "UL1 Source"},
+	{"UL2", NULL, "UL2 Source"},
+	{"UL3", NULL, "UL3 Source"},
+};
+
+static struct snd_soc_dai_driver rtk_dai_memif_driver[] = {
+	// FE DAIs: memory interfaces to CPU
+	{
+		.name = "DL1",
+		.id = RTK_DAI_MEMIF_DL1,
+		.playback = {
+			.stream_name = "DL1",
+			.channels_min = 1,
+			.channels_max = 8,
+			.rates = RTK_PCM_RATES,
+			.formats = RTK_PCM_FORMATS,
+		},
+		.ops = &rtk_dai_fe_ops,
+	},
+	{
+		.name = "DL2",
+		.id = RTK_DAI_MEMIF_DL2,
+		.playback = {
+			.stream_name = "DL2",
+			.channels_min = 1,
+			.channels_max = 8,
+			.rates = RTK_PCM_RATES,
+			.formats = RTK_PCM_FORMATS,
+		},
+		.ops = &rtk_dai_fe_ops,
+	},
+	{
+		.name = "DL3",
+		.id = RTK_DAI_MEMIF_DL3,
+		.playback = {
+			.stream_name = "DL3",
+			.channels_min = 1,
+			.channels_max = 8,
+			.rates = RTK_PCM_RATES,
+			.formats = RTK_PCM_FORMATS,
+		},
+		.ops = &rtk_dai_fe_ops,
+	},
+	{
+		.name = "UL1",
+		.id = RTK_DAI_MEMIF_UL1,
+		.capture = {
+			.stream_name = "UL1",
+			.channels_min = 1,
+			.channels_max = 8,
+			.rates = RTK_PCM_RATES,
+			.formats = RTK_PCM_FORMATS,
+		},
+		.ops = &rtk_dai_fe_ops,
+	},
+	{
+		.name = "UL2",
+		.id = RTK_DAI_MEMIF_UL2,
+		.capture = {
+			.stream_name = "UL2",
+			.channels_min = 1,
+			.channels_max = 8,
+			.rates = RTK_PCM_RATES,
+			.formats = RTK_PCM_FORMATS,
+		},
+		.ops = &rtk_dai_fe_ops,
+	},
+	{
+		.name = "UL3",
+		.id = RTK_DAI_MEMIF_UL3,
+		.capture = {
+			.stream_name = "UL3",
+			.channels_min = 1,
+			.channels_max = 8,
+			.rates = RTK_PCM_RATES,
+			.formats = RTK_PCM_FORMATS,
+		},
+		.ops = &rtk_dai_fe_ops,
+	},
+};
+
+static void init_memif_priv_data(struct rtk_afe_priv *afe)
+{
+	int i;
+
+	for (i = RTK_DAI_MEMIF_START; i < RTK_DAI_MEMIF_END; i++)
+		afe->dai_priv[i] = (void *)&afe->memif[i];
+}
+
+static int rtk_dai_memif_register(struct rtk_afe_priv *afe)
+{
+	struct rtk_afe_dai *dai;
+
+	dai = devm_kzalloc(afe->dev, sizeof(*dai), GFP_KERNEL);
+	if (!dai)
+		return -ENOMEM;
+
+	list_add(&dai->list, &afe->sub_dais);
+
+	dai->dai_drivers = rtk_dai_memif_driver;
+	dai->num_dai_drivers = ARRAY_SIZE(rtk_dai_memif_driver);
+	dai->dapm_widgets = rtk_dai_memif_widgets;
+	dai->num_dapm_widgets = ARRAY_SIZE(rtk_dai_memif_widgets);
+	dai->dapm_routes = rtk_dai_memif_routes;
+	dai->num_dapm_routes = ARRAY_SIZE(rtk_dai_memif_routes);
+
+	init_memif_priv_data(afe);
+
+	return 0;
+}
+
+typedef int (*dai_register_cb)(struct rtk_afe_priv *);
+static const dai_register_cb dai_register_cbs[] = {
+	rtk_dai_i2s_register,
+	rtk_dai_aio_register,
+	rtk_dai_memif_register,
+};
+
+static int rtk_snd_monitor_latency(struct snd_pcm_substream *substream,
+				   struct rtk_afe_memif *memif)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct rtk_snd_ringbuf *buf = memif->ringbuf;
+	struct ringbuf_header_ptrs *hdr = buf->hdr_ptrs;
+	struct alsa_latency_info *fw_info, info;
+	unsigned int retry = 0;
+	unsigned int hwring_wp;
+	unsigned int wp_buffer;
+	unsigned int wp_frame = 0;
+	u64 pcm_pts, cur_pts, diff_pts;
+	u64 queuebuffer;
+	int audio_latency;
+
+	fw_info = hdr->p_latency;
+
+	memcpy(&info, fw_info, sizeof(*fw_info));
+
+	while(info.sum != (info.latency + info.ptsl)) {
+		if (retry > 100) {
+			if (info.ptsl < info.sum)
+				info.latency = info.sum - info.ptsl;
+			break;
+		}
+		memcpy(&info, fw_info, sizeof(*fw_info));
+		retry++;
+	}
+
+	hwring_wp = *hdr->p_write_ptr;
+
+	pcm_pts = ((u64)info.ptsh << 32) | ((u64)info.ptsl);
+	cur_pts = (u64)refclk_get_val_raw();
+	diff_pts = cur_pts - pcm_pts;
+
+	if (info.decin_wp != hwring_wp) {
+		wp_buffer = ring_valid_data(*hdr->p_begin_addr,
+					*hdr->p_begin_addr + *hdr->p_size,
+					*hdr->p_read_ptr,
+					*hdr->p_write_ptr);
+		wp_frame = bytes_to_frames(runtime, wp_buffer);
+	}
+
+	queuebuffer = wp_frame +
+			ring_valid_data(0, runtime->boundary,
+					memif->total_write,
+					runtime->control->appl_ptr);
+	queuebuffer = div_u64(queuebuffer * 1000000, runtime->rate);
+	audio_latency = info.latency + queuebuffer - div64_ul(diff_pts * 1000, 90);
+	audio_latency = audio_latency / 1000;
+
+	if (audio_latency < 0)
+		audio_latency = 0;
+
+	return audio_latency;
+}
+
+static int rtk_snd_mmap(struct dma_buf *dmabuf, struct vm_area_struct *vma)
+{
+	struct rtk_snd_ringbuf *buf = dmabuf->priv;
+	struct snd_dma_buffer *dmab = buf->dmab;
+	struct device *dev = dmab->dev.dev;
+	dma_addr_t paddr = dmab->addr;
+	void *vaddr = dmab->area;
+	size_t size = vma->vm_end - vma->vm_start;
+
+	if (vaddr)
+		return dma_mmap_coherent(dev, vma, vaddr, paddr, size);
+
+	return 0;
+}
+
+static void rtk_snd_release(struct dma_buf *dmabuf)
+{
+	struct rtk_snd_ringbuf *buf = dmabuf->priv;
+
+	kref_put(&buf->ref, rtk_snd_ringbuf_destroy);
+}
+
+static const struct dma_buf_ops rtk_snd_dmabuf_ops = {
+	.mmap = rtk_snd_mmap,
+	.release = rtk_snd_release,
+};
+
+static int rtk_hwdep_ioctl(struct snd_hwdep *hwdep, struct file *file,
+			   unsigned int cmd, unsigned long arg)
+{
+	struct rtk_snd_ringbuf *buf;
+	struct snd_pcm_substream *substream;
+	struct rtk_pcm_runtime_priv *pcm_priv;
+	struct rtk_pcm_mmap_fd __user *mmap_fd;
+	struct dma_buf *dmabuf;
+	int ret = 0, stream = -1;
+	int i, fd, latency;
+
+	DEFINE_DMA_BUF_EXPORT_INFO(exp_info);
+
+	for_each_pcm_substream(substream->pcm, i, substream)
+		stream = i;
+	if (!substream || !substream->runtime) {
+		ret = -ENODEV;
+		goto err_exit;
+	}
+	pcm_priv = substream->runtime->private_data;
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK && !pcm_priv->memif) {
+		ret = -ENOMEM;
+		goto err_exit;
+	}
+
+	switch (cmd) {
+	case SNDRV_PCM_IOCTL_MMAP_DATA_FD:
+		if (stream != SNDRV_PCM_STREAM_PLAYBACK) {
+			ret = -EINVAL;
+			goto err_exit;
+		}
+		mmap_fd = (struct rtk_pcm_mmap_fd __user *)arg;
+
+		buf = pcm_priv->memif->ringbuf;
+
+		exp_info.ops = &rtk_snd_dmabuf_ops;
+		exp_info.size = buf->dmab->bytes;
+		exp_info.flags = O_RDWR;
+		exp_info.priv = buf;
+		kref_get(&buf->ref);
+
+		dmabuf = dma_buf_export(&exp_info);
+		if (IS_ERR(dmabuf))
+			goto err_export_buf;
+		fd = dma_buf_fd(dmabuf, O_CLOEXEC);
+		if (fd < 0)
+			goto err_get_fd;
+		if (put_user(fd, &mmap_fd->fd))
+			goto err_get_fd;
+		break;
+
+err_get_fd:
+		dma_buf_put(dmabuf);
+err_export_buf:
+		pr_err("%s: err mmap data fd\n", __func__);
+		kref_put(&buf->ref, rtk_snd_ringbuf_destroy);
+		ret = -1;
+		break;
+
+	case SNDRV_PCM_IOCTL_GET_LATENCY:
+		if (stream != SNDRV_PCM_STREAM_PLAYBACK) {
+			ret = -EINVAL;
+			goto err_exit;
+		}
+
+		buf = pcm_priv->memif->ringbuf;
+		latency = rtk_snd_monitor_latency(substream, pcm_priv->memif);
+		ret = put_user(latency, (int __user *)arg);
+		break;
+
+	case SNDRV_PCM_IOCTL_MIX_IDX_SET:
+		if (stream != SNDRV_PCM_STREAM_PLAYBACK) {
+			ret = -EINVAL;
+			goto err_exit;
+		}
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	};
+
+err_exit:
+	return ret;
+}
+
+#ifdef CONFIG_COMPAT
+static int rtk_hwdep_compat_ioctl(struct snd_hwdep *hwdep, struct file *file,
+				  unsigned int cmd, unsigned long arg)
+{
+	return rtk_hwdep_ioctl(hwdep, file, cmd, (unsigned long)compat_ptr(arg));
+}
+#else
+#define rtk_hwdep_compat_ioctl NULL
+#endif
+
+static int rtk_snd_create_hwdep(struct snd_pcm *pcm)
+{
+	static const struct snd_hwdep_ops ops = {
+		.ioctl		= rtk_hwdep_ioctl,
+		.ioctl_compat	= rtk_hwdep_compat_ioctl,
+	};
+	struct snd_hwdep *hwdep;
+	int ret;
+
+	ret = snd_hwdep_new(pcm->card, pcm->name, pcm->device, &hwdep);
+	if (ret)
+		return ret;
+
+	strncpy(hwdep->name, pcm->name, sizeof(hwdep->name) - 1);
+	hwdep->iface = pcm->device;
+	hwdep->ops = ops;
+	hwdep->private_data = pcm;
+	hwdep->exclusive = true;
+
+	return 0;
+}
+
+static int rtk_afe_component_probe(struct snd_soc_component *component)
+{
+	struct rtk_afe_priv *afe = snd_soc_component_get_drvdata(component);
+	struct rtk_afe_dai *dai;
+
+	list_for_each_entry(dai, &afe->sub_dais, list) {
+		if (dai->controls)
+			snd_soc_add_component_controls(component,
+						       dai->controls,
+						       dai->num_controls);
+
+		if (dai->dapm_widgets)
+			snd_soc_dapm_new_controls(&component->dapm,
+						  dai->dapm_widgets,
+						  dai->num_dapm_widgets);
+	}
+	/* add routes after all widgets are added */
+	list_for_each_entry(dai, &afe->sub_dais, list) {
+		if (dai->dapm_routes)
+			snd_soc_dapm_add_routes(&component->dapm,
+						dai->dapm_routes,
+						dai->num_dapm_routes);
+	}
+
+	snd_soc_dapm_new_widgets(component->dapm.card);
+
+	return 0;
+}
+
+static int rtk_afe_pcm_new(struct snd_soc_component *component,
+			   struct snd_soc_pcm_runtime *rtd)
+{
+	struct rtk_afe_priv *afe = snd_soc_component_get_drvdata(component);
+	struct snd_pcm *pcm = rtd->pcm;
+	struct snd_pcm_substream *substream;
+	size_t size;
+
+	size = afe->rtk_afe_hardware->buffer_bytes_max;
+	substream = pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream;
+	if (substream)
+		snd_pcm_set_managed_buffer(substream, SNDRV_DMA_TYPE_DEV_WC_SG,
+					   afe->dev, size, size);
+
+	rtk_snd_create_hwdep(pcm);
+	return 0;
+}
+
+snd_pcm_uframes_t rtk_afe_pcm_pointer(struct snd_soc_component *component,
+				      struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
+	struct rtk_afe_priv *afe = snd_soc_component_get_drvdata(component);
+	struct rtk_afe_memif *memif = &afe->memif[asoc_rtd_to_cpu(rtd, 0)->id];
+	struct ringbuf_header_ptrs *header = memif->ringbuf->hdr_ptrs;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	snd_pcm_uframes_t read_addsize = 0;
+	unsigned int hw_ringrp;
+	snd_pcm_uframes_t ret = 0;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		hw_ringrp = *header->p_read_ptr;
+		memif->hw_ptr = bytes_to_frames(runtime,
+					(size_t)(hw_ringrp - *header->p_begin_addr));
+		if (memif->hw_ptr != memif->prehw_ptr) {
+			read_addsize = ring_valid_data(0, runtime->buffer_size,
+						       memif->prehw_ptr, memif->hw_ptr);
+
+			memif->total_read = ring_add(0, runtime->boundary,
+						     memif->total_read, read_addsize);
+		}
+		memif->prehw_ptr = memif->hw_ptr;
+		ret = memif->total_read % runtime->buffer_size;
+	} else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		ret = memif->total_write % runtime->buffer_size;
+	}
+	return ret;
+}
+
+static int rtk_afe_pcm_ack(struct snd_soc_component *component,
+			   struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
+	struct rtk_afe_priv *afe = snd_soc_component_get_drvdata(component);
+	struct rtk_afe_memif *memif = &afe->memif[asoc_rtd_to_cpu(rtd, 0)->id];
+	struct ringbuf_header_ptrs *header = memif->ringbuf->hdr_ptrs;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	unsigned int period_count = 0;
+	unsigned int hw_ring_free_size;
+	unsigned int hw_ring_free_frame;
+	unsigned int hw_ringrp;
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+		return 0;
+
+	hw_ringrp = *header->p_read_ptr;
+
+	/* update wp (the pointer application send data to alsa) */
+	period_count = ring_valid_data(0, runtime->boundary,
+				       memif->total_write,
+				       runtime->control->appl_ptr) / runtime->period_size;
+
+	/* Check the buffer available size between alsa and FW */
+	hw_ring_free_size =
+		valid_free_size(*header->p_begin_addr,
+				*header->p_begin_addr + *header->p_size,
+				hw_ringrp,
+				*header->p_write_ptr);
+
+	hw_ring_free_frame = bytes_to_frames(runtime, hw_ring_free_size);
+
+	if ((runtime->period_size * period_count) > hw_ring_free_frame)
+		period_count = hw_ring_free_frame / runtime->period_size;
+
+	if (hw_ring_free_size <= frames_to_bytes(runtime, runtime->period_size))
+		period_count = 0;
+
+	if (period_count) {
+		*header->p_write_ptr =
+			ring_add(*header->p_begin_addr,
+				 *header->p_begin_addr + *header->p_size,
+				 *header->p_write_ptr,
+				 frames_to_bytes(runtime,
+				 runtime->period_size * period_count));
+		memif->total_write =
+			ring_add(0, runtime->boundary,
+				 memif->total_write,
+				 runtime->period_size * period_count);
+	}
+	return 0;
+}
+
+static int rtk_afe_pcm_mmap(struct snd_soc_component *component, struct snd_pcm_substream *substream,
+                            struct vm_area_struct *area)
+{
+	struct snd_dma_buffer *dmab = substream->runtime->dma_buffer_p;
+	struct device *dev = dmab->dev.dev;
+	dma_addr_t daddr = dmab->addr;
+	void *vaddr = dmab->area;
+	size_t size = area->vm_end - area->vm_start;
+
+	if (vaddr)
+		return dma_mmap_coherent(dev, area, vaddr, daddr, size);
+
+	return 0;
+}
+
+static const struct snd_soc_component_driver rtk_afe_component = {
+	.name = AFE_PCM_NAME,
+	.probe = rtk_afe_component_probe,
+	.pcm_construct = rtk_afe_pcm_new,
+	.pointer = rtk_afe_pcm_pointer,
+	.ack = rtk_afe_pcm_ack,
+	.mmap = rtk_afe_pcm_mmap,
+};
+
+int rtk_afe_combine_sub_dai(struct rtk_afe_priv *afe)
+{
+	struct rtk_afe_dai *dai;
+	size_t num_dai_drivers = 0, dai_idx = 0;
+
+	/* calcualte total dai driver size */
+	list_for_each_entry(dai, &afe->sub_dais, list) {
+		num_dai_drivers += dai->num_dai_drivers;
+	}
+
+	dev_info(afe->dev, "%s(), num of dai %zd\n", __func__, num_dai_drivers);
+
+	/* combine sub_dais */
+	afe->num_dai_drivers = num_dai_drivers;
+	afe->dai_drivers = devm_kcalloc(afe->dev,
+					num_dai_drivers,
+					sizeof(struct snd_soc_dai_driver),
+					GFP_KERNEL);
+	if (!afe->dai_drivers)
+		return -ENOMEM;
+
+	list_for_each_entry(dai, &afe->sub_dais, list) {
+		/* dai driver */
+		memcpy(&afe->dai_drivers[dai_idx],
+		       dai->dai_drivers,
+		       dai->num_dai_drivers *
+		       sizeof(struct snd_soc_dai_driver));
+		dai_idx += dai->num_dai_drivers;
+	}
+
+	return 0;
+}
+
+/* todo probe function review */
+static int rtk_afe_pcm_probe(struct platform_device *pdev)
+{
+	struct rtk_afe_priv *afe;
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	struct rtk_krpc_ept_info *hifi_ept;
+	dma_addr_t paddr;
+	void *vaddr;
+	int cache_cfg, i, ret;
+
+	afe = devm_kzalloc(dev, sizeof(*afe), GFP_KERNEL);
+	if (!afe)
+		return -ENOMEM;
+
+	afe->memif = devm_kcalloc(dev, RTK_DAI_MEMIF_NUM, sizeof(*afe->memif),
+				  GFP_KERNEL);
+	if (!afe->memif)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, afe);
+	afe->data = of_device_get_match_data(dev);
+	afe->dev = dev;
+
+	/* prepare kernel rpc */
+	hifi_ept = of_krpc_ept_info_get(np, 0);
+	if (IS_ERR(hifi_ept))
+		return dev_err_probe(dev, PTR_ERR(hifi_ept),
+				     "fail to get HIFI krpc ept: 0x%lx\n",
+				     PTR_ERR(hifi_ept));
+
+	set_dma_ops(dev, &rheap_dma_ops);
+
+	rheap_setup_dma_pools(dev, "rtk_media_heap", RTK_ACPU_FLAGS, __func__);
+	vaddr = dma_alloc_coherent(dev, SZ_4K, &paddr, GFP_KERNEL);
+	if (!vaddr)
+		return -ENOMEM;
+
+	afe->rpc_priv.ept = hifi_ept;
+	afe->rpc_priv.paddr = paddr;
+	afe->rpc_priv.vaddr = vaddr;
+
+	rpc_ept_init(&afe->rpc_priv);
+
+	/* init sub_dais */
+	INIT_LIST_HEAD(&afe->sub_dais);
+
+	for (i = 0; i < ARRAY_SIZE(dai_register_cbs); i++) {
+		ret = dai_register_cbs[i](afe);
+		if (ret) {
+			dev_warn(afe->dev, "dai register i %d fail, ret %d\n",
+				 i, ret);
+			goto err_pm_disable;
+		}
+	}
+
+	/* init dai_driver and component_driver */
+	ret = rtk_afe_combine_sub_dai(afe);
+	if (ret) {
+		dev_warn(afe->dev, "rtk_afe_combine_sub_dai fail, ret %d\n",
+			 ret);
+		goto err_pm_disable;
+	}
+
+	afe->rtk_afe_hardware = &rtk_afe_hardware;
+
+	rpc_get_chache_config(&afe->rpc_priv,&cache_cfg);
+
+	if (cache_cfg == ENUM_MEMORY_CFG_ALL_CACHE)
+		afe->fw_mem_cfg = 1;
+	else if (cache_cfg == ENUM_MEMORY_CFG_WITH_UNCACHE)
+		afe->fw_mem_cfg = 0;
+	else {
+		dev_err(dev,"UNKNOW FW memory config %d\n",cache_cfg);
+		goto err_pm_disable;
+	}
+
+	ret = devm_snd_soc_register_component(dev, &rtk_afe_component,
+					      afe->dai_drivers,
+					      afe->num_dai_drivers);
+	if (ret) {
+		dev_warn(dev, "err register dai component\n");
+		goto err_pm_disable;
+	}
+
+	return 0;
+err_pm_disable:
+//	pm_runtime_disable(&pdev->dev);
+
+	return ret;
+}
+
+static int rtk_afe_pcm_remove(struct platform_device *pdev)
+{
+	struct rtk_afe_priv *afe = platform_get_drvdata(pdev);
+
+	dma_free_coherent(&pdev->dev, SZ_4K,
+			  afe->rpc_priv.vaddr, afe->rpc_priv.paddr);
+
+	return 0;
+}
+
+static const struct of_device_id rtk_afe_pcm_dt_match[] = {
+	{ .compatible = "realtek,rtd1920s-hifi-afe", .data = &kent_afe },
+	{ .compatible = "realtek,kent-2ao-afe", .data = &kent_2ao_afe },
+	{ .compatible = "realtek,rtd1325-hifi-afe", .data = &morbius_afe },
+	{ .compatible = "realtek,rtd1619b-hifi-afe", .data = &stark_afe },
+	{},
+};
+MODULE_DEVICE_TABLE(of, rtk_afe_pcm_dt_match);
+
+static struct platform_driver rtk_afe_pcm_driver = {
+	.driver = {
+		   .name = "rtk-hifi-afe",
+		   .of_match_table = rtk_afe_pcm_dt_match,
+	},
+	.probe = rtk_afe_pcm_probe,
+	.remove = rtk_afe_pcm_remove,
+};
+
+module_platform_driver(rtk_afe_pcm_driver);
+
+MODULE_DESCRIPTION("Realtek ALSA SoC AFE platform driver");
+MODULE_AUTHOR("Simon Hsu <simon_hsu@realtek.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/realtek/rtk-dai-aio.c b/sound/soc/realtek/rtk-dai-aio.c
new file mode 100644
index 000000000000..b7568e50e540
--- /dev/null
+++ b/sound/soc/realtek/rtk-dai-aio.c
@@ -0,0 +1,333 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// RealTek ALSA SoC Audio DAI AIO Control
+//
+// Copyright (c) 2024 RealTek Inc.
+// Author: Simon Hsu <simon_hsu@realtek.com>
+//
+
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+#include "rtk-afe-common.h"
+
+#define RTK_AIO_FORMATS (SNDRV_PCM_FMTBIT_S8 | \
+			SNDRV_PCM_FMTBIT_S16_LE | \
+			SNDRV_PCM_FMTBIT_S24_LE | \
+			SNDRV_PCM_FMTBIT_S24_3LE)
+
+#define RTK_AIO_RATES (SNDRV_PCM_RATE_8000_48000 | \
+			SNDRV_PCM_RATE_88200 | \
+			SNDRV_PCM_RATE_96000 | \
+			SNDRV_PCM_RATE_176400 | \
+			SNDRV_PCM_RATE_192000)
+
+#define RTK_SOC_SINGLE_BOOL_EXT(xname, xdata, xhandler_get, xhandler_put, id) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.info = snd_soc_info_bool_ext, \
+	.get = xhandler_get, .put = xhandler_put, \
+	.device = id, \
+	.private_value = xdata }
+
+struct rtk_dai_aio_priv {
+	unsigned int ao_id;
+	struct rpc_aio_ctrl ctrl;
+
+	unsigned int ai_id;
+	struct rtk_snd_ringbuf *airing;
+	unsigned int lb_secure;
+};
+
+static const char * const ao_lb_src_sel_mux_text[] = {
+	"i2s", "spdif",
+};
+
+static SOC_ENUM_SINGLE_DECL(ao_lb_src_sel_mux_enum,
+	SND_SOC_NOPM, 0, ao_lb_src_sel_mux_text);
+
+static const struct snd_kcontrol_new ao_lb_src_sel_mux =
+	SOC_DAPM_ENUM("ao lb src sel", ao_lb_src_sel_mux_enum);
+
+static const struct snd_soc_dapm_widget rtk_dai_aio_widgets[] = {
+	SND_SOC_DAPM_MUX("AO Loopback Source", SND_SOC_NOPM, 0, 0, &ao_lb_src_sel_mux),
+};
+
+static const struct snd_soc_dapm_route rtk_dai_aio_routes[] = {
+	{ "AUDIO_OUT0", NULL, "DL1" },
+	{ "AUDIO_OUT0", NULL, "DL2" },
+	{ "AUDIO_OUT0", NULL, "DL3" },
+	{ "AUDIO_OUT0", NULL, "DL4" },
+
+	{ "UL1 Source", "ao_lb", "AO Loopback Source" },
+	{ "UL2 Source", "ao_lb", "AO Loopback Source" },
+	{ "UL3 Source", "ao_lb", "AO Loopback Source" },
+
+	{ "AO Loopback Source", "i2s", "I2S0_LOOPBACK" },
+};
+
+static int rtk_aio_hdmi_ctrl_get(struct snd_kcontrol *kcontrol,
+				 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *cmpnt = snd_soc_kcontrol_component(kcontrol);
+	struct rtk_afe_priv *afe = snd_soc_component_get_drvdata(cmpnt);
+	struct rtk_dai_aio_priv *aio_priv;
+	struct rpc_aio_ctrl *ctrl;
+	unsigned int dai_id = kcontrol->id.device;
+	int value;
+
+	aio_priv = afe->dai_priv[dai_id];
+	ctrl = &aio_priv->ctrl;
+
+	value = (ctrl->bitmap & (1 << ENUM_DT_AO_HDMI)) >> ENUM_DT_AO_HDMI;
+	ucontrol->value.integer.value[0] = !value;
+
+	return 0;
+};
+
+static int rtk_aio_hdmi_ctrl_set(struct snd_kcontrol *kcontrol,
+				 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *cmpnt = snd_soc_kcontrol_component(kcontrol);
+	struct rtk_afe_priv *afe = snd_soc_component_get_drvdata(cmpnt);
+	struct rtk_dai_aio_priv *aio_priv;
+	struct rpc_aio_ctrl *ctrl;
+	unsigned int dai_id = kcontrol->id.device;
+	int value;
+
+	aio_priv = afe->dai_priv[dai_id];
+	ctrl = &aio_priv->ctrl;
+
+	value = (~ctrl->bitmap & (1 << ENUM_DT_AO_HDMI)) >> ENUM_DT_AO_HDMI;
+	if (value != ucontrol->value.integer.value[0]) {
+		value = ctrl->bitmap & ~(1 << ENUM_DT_AO_HDMI);
+		value |= (!ucontrol->value.integer.value[0]) << ENUM_DT_AO_HDMI;
+		ctrl->bitmap = value;
+		return rpc_ctrl_aio(&afe->rpc_priv, aio_priv->ao_id, ctrl);
+	}
+
+	return 0;
+}
+
+static const struct snd_kcontrol_new rtk_dai_aio_controls[] = {
+	RTK_SOC_SINGLE_BOOL_EXT("HDMI Audio Out", 0,
+				rtk_aio_hdmi_ctrl_get, rtk_aio_hdmi_ctrl_set,
+				RTK_DAI_AUDIO_OUT0),
+};
+
+static int rtk_dai_aio_hw_params(struct snd_pcm_substream *substream,
+				 struct snd_pcm_hw_params *params,
+				 struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static int rtk_dai_aio_hw_free(struct snd_pcm_substream *substream,
+			       struct snd_soc_dai *dai)
+{
+	struct rtk_afe_priv *afe = snd_soc_dai_get_drvdata(dai);
+	struct rtk_dai_aio_priv *aio_priv;
+
+	aio_priv = afe->dai_priv[dai->id];
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+		rtk_snd_free_ringbuf(&aio_priv->airing);
+
+	return 0;
+}
+
+static void rtk_runtime_priv_free(struct snd_pcm_runtime *runtime)
+{
+	kfree(runtime->private_data);
+	runtime->private_data = NULL;
+}
+
+static int rtk_dai_aio_startup(struct snd_pcm_substream *substream,
+			       struct snd_soc_dai *dai)
+{
+	struct rtk_afe_priv *afe = snd_soc_dai_get_drvdata(dai);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct rtk_dai_aio_priv *aio_priv;
+	struct rtk_pcm_runtime_priv *pcm_priv;
+
+	aio_priv = afe->dai_priv[dai->id];
+
+	pcm_priv = kzalloc(sizeof(*pcm_priv), GFP_KERNEL);
+	if (!pcm_priv)
+		return -ENOMEM;
+	runtime->private_data = pcm_priv;
+	runtime->private_free = rtk_runtime_priv_free;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		pcm_priv->ao_id = aio_priv->ao_id;
+		dev_info(afe->dev, "%s ao_id = 0x%x\n", __func__, aio_priv->ao_id);
+	} else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		rpc_create_audio_agent(&afe->rpc_priv, AUDIO_IN, &aio_priv->ai_id);
+		pcm_priv->ai_id = aio_priv->ai_id;
+		dev_info(afe->dev, "%s ai_id = 0x%x\n", __func__, aio_priv->ai_id);
+	}
+
+	return 0;
+}
+
+static int rtk_dai_aio_prepare(struct snd_pcm_substream *substream,
+			       struct snd_soc_dai *dai)
+{
+	struct rtk_afe_priv *afe = snd_soc_dai_get_drvdata(dai);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct rpc_ringbuffer_header ring_header = {0};
+	struct rtk_dai_aio_priv *aio_priv;
+	unsigned long heap_flags;
+	int ret;
+
+	aio_priv = afe->dai_priv[dai->id];
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		if (aio_priv->lb_secure)
+			heap_flags = RTK_SECURE_FLAGS;
+		else
+			heap_flags = RTK_ACPU_FLAGS;
+		if (dai->id == RTK_DAI_I2S0_LOOPBACK) {
+			ring_header.instance_id = aio_priv->ai_id;
+			ring_header.pin_id = PCM_OUT;
+			ring_header.read_idx = -1;
+			ret = rtk_snd_prepare_ringbuf(afe, NULL,
+						      RTK_ENC_AI_BUFFER_SIZE,
+						      runtime->channels,
+						      &aio_priv->airing,
+						      &ring_header,
+						      heap_flags);
+			if (ret)
+				goto err_alloc_ringbuf;
+
+			ret = rpc_config_loopback_in(&afe->rpc_priv, aio_priv->ai_id);
+			if (ret)
+				goto err_send_rpc;
+		}
+	}
+	return 0;
+
+err_send_rpc:
+err_alloc_ringbuf:
+	rtk_snd_free_ringbuf(&aio_priv->airing);
+	return ret;
+}
+
+static const struct snd_soc_dai_ops rtk_dai_aio_ops = {
+	.startup	= rtk_dai_aio_startup,
+	.hw_params	= rtk_dai_aio_hw_params,
+	.hw_free	= rtk_dai_aio_hw_free,
+	.prepare	= rtk_dai_aio_prepare,
+};
+
+static struct snd_soc_dai_driver rtk_dai_aio_driver[] = {
+	{
+		.name = "AUDIO_OUT0",
+		.id = RTK_DAI_AUDIO_OUT0,
+		.playback = {
+			.stream_name = "AUDIO_OUT0",
+			.channels_min = 1,
+			.channels_max = 8,
+			.rates = RTK_AIO_RATES,
+			.formats = RTK_AIO_FORMATS,
+		},
+		.ops = &rtk_dai_aio_ops,
+	},
+	{
+		.name = "AUDIO_OUT1",
+		.id = RTK_DAI_AUDIO_OUT1,
+		.playback = {
+			.stream_name = "AUDIO_OUT1",
+			.channels_min = 1,
+			.channels_max = 8,
+			.rates = RTK_AIO_RATES,
+			.formats = RTK_AIO_FORMATS,
+		},
+		.ops = &rtk_dai_aio_ops,
+	},
+	{
+		.name = "I2S0_LOOPBACK",
+		.id = RTK_DAI_I2S0_LOOPBACK,
+		.capture = {
+			.stream_name = "I2S0_LOOPBACK",
+			.channels_min = 1,
+			.channels_max = 8,
+			.rates = RTK_AIO_RATES,
+			.formats = RTK_AIO_FORMATS,
+		},
+		.ops = &rtk_dai_aio_ops,
+	},
+};
+
+static int init_aio_priv_data(struct rtk_afe_priv *afe)
+{
+	struct rtk_dai_aio_priv *aio_priv;
+	struct rpc_aio_ctrl *ctrl;
+	int ret, i, type;
+
+	for (i = RTK_DAI_AO_START; i < (RTK_DAI_AO_START + afe->data->ao_num); i++) {
+		aio_priv = devm_kzalloc(afe->dev,
+					sizeof(struct rtk_dai_aio_priv),
+					GFP_KERNEL);
+		if (!aio_priv)
+			return -ENOMEM;
+
+		afe->dai_priv[i] = aio_priv;
+
+		if (i == RTK_DAI_AUDIO_OUT0)
+			type = AUDIO_OUT;
+		else if (i == RTK_DAI_AUDIO_OUT1)
+			type = AUDIO_OUT2;
+
+		ret = rpc_create_audio_agent(&afe->rpc_priv, type, &aio_priv->ao_id);
+		if (ret)
+			goto err_send_rpc;
+
+		ctrl = &aio_priv->ctrl;
+		ctrl->bitmap = afe->data->ao_bitmap_mask;
+		ctrl->bitmap &= ~(1 << ENUM_DT_AO_HDMI);
+		ctrl->bitmap &= ~(1 << ENUM_DT_AO_I2S);
+		ctrl->bitmap &= ~(1 << ENUM_DT_AO_DAC);
+		ctrl->bitmap &= ~(1 << ENUM_DT_AO_GLOBAL);
+		ctrl->i2s_ch = afe->data->i2s_out_ch;
+		ctrl->i2s_mode = RTK_AUDIO_OUT_I2S_MODE_MASTER;
+
+		ret = rpc_ctrl_aio(&afe->rpc_priv, aio_priv->ao_id, ctrl);
+		if (ret)
+			goto err_send_rpc;
+	}
+	for (i = RTK_DAI_AI_START; i < RTK_DAI_AI_END; i++) {
+		aio_priv = devm_kzalloc(afe->dev,
+					sizeof(struct rtk_dai_aio_priv),
+					GFP_KERNEL);
+		if (!aio_priv)
+			return -ENOMEM;
+
+		afe->dai_priv[i] = aio_priv;
+		aio_priv->lb_secure = afe->data->lb_secure;
+	}
+
+err_send_rpc:
+	return ret;
+}
+
+int rtk_dai_aio_register(struct rtk_afe_priv *afe)
+{
+	struct rtk_afe_dai *dai;
+
+	dai = devm_kzalloc(afe->dev, sizeof(*dai), GFP_KERNEL);
+	if (!dai)
+		return -ENOMEM;
+
+	list_add(&dai->list, &afe->sub_dais);
+
+	dai->dai_drivers = rtk_dai_aio_driver;
+	dai->num_dai_drivers = ARRAY_SIZE(rtk_dai_aio_driver);
+	dai->dapm_widgets = rtk_dai_aio_widgets;
+	dai->num_dapm_widgets = ARRAY_SIZE(rtk_dai_aio_widgets);
+	dai->dapm_routes = rtk_dai_aio_routes;
+	dai->num_dapm_routes = ARRAY_SIZE(rtk_dai_aio_routes);
+	dai->controls = rtk_dai_aio_controls;
+	dai->num_controls = ARRAY_SIZE(rtk_dai_aio_controls);
+
+	return init_aio_priv_data(afe);
+}
diff --git a/sound/soc/realtek/rtk-dai-i2s.c b/sound/soc/realtek/rtk-dai-i2s.c
new file mode 100644
index 000000000000..879215ffc65c
--- /dev/null
+++ b/sound/soc/realtek/rtk-dai-i2s.c
@@ -0,0 +1,196 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// RealTek ALSA SoC Audio DAI I2S Control
+//
+// Copyright (c) 2024 RealTek Inc.
+// Author: Simon Hsu <simon_hsu@realtek.com>
+//
+
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+#include "rtk-afe-common.h"
+
+#define RTK_I2S_FORMATS (SNDRV_PCM_FMTBIT_S8 | \
+				SNDRV_PCM_FMTBIT_S16_LE | \
+				SNDRV_PCM_FMTBIT_S24_LE | \
+				SNDRV_PCM_FMTBIT_S24_3LE)
+
+#define RTK_I2S_RATES (SNDRV_PCM_RATE_8000_48000 | \
+			SNDRV_PCM_RATE_88200 | \
+			SNDRV_PCM_RATE_96000 | \
+			SNDRV_PCM_RATE_176400 | \
+			SNDRV_PCM_RATE_192000)
+
+struct rtk_dai_i2s_priv {
+	unsigned int ai_id;
+	struct rtk_snd_ringbuf *airing;
+};
+
+static const struct snd_soc_dapm_route rtk_dai_i2s_routes[] = {
+	{"UL1 Source", "i2s", "I2S0_IN"},
+	{"UL2 Source", "i2s", "I2S0_IN"},
+	{"UL3 Source", "i2s", "I2S0_IN"},
+};
+
+static void rtk_runtime_priv_free(struct snd_pcm_runtime *runtime)
+{
+	kfree(runtime->private_data);
+	runtime->private_data = NULL;
+}
+
+static int rtk_dai_i2s_startup(struct snd_pcm_substream *substream,
+			       struct snd_soc_dai *dai)
+{
+	struct rtk_afe_priv *afe = snd_soc_dai_get_drvdata(dai);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct rtk_dai_i2s_priv *i2s_priv;
+	struct rtk_pcm_runtime_priv *pcm_priv;
+
+	i2s_priv = afe->dai_priv[dai->id];
+
+	pcm_priv = kzalloc(sizeof(*pcm_priv), GFP_KERNEL);
+	if (!pcm_priv)
+		return -ENOMEM;
+	runtime->private_data = pcm_priv;
+	runtime->private_free = rtk_runtime_priv_free;
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		rpc_create_audio_agent(&afe->rpc_priv, AUDIO_IN, &i2s_priv->ai_id);
+
+		pcm_priv->ai_id = i2s_priv->ai_id;
+	}
+
+	return 0;
+}
+
+static int rtk_dai_i2s_hw_params(struct snd_pcm_substream *substream,
+				 struct snd_pcm_hw_params *params,
+				 struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static int rtk_dai_i2s_hw_free(struct snd_pcm_substream *substream,
+			       struct snd_soc_dai *dai)
+{
+	struct rtk_afe_priv *afe = snd_soc_dai_get_drvdata(dai);
+	struct rtk_dai_i2s_priv *i2s_priv;
+
+	i2s_priv = afe->dai_priv[dai->id];
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+		rtk_snd_free_ringbuf(&i2s_priv->airing);
+
+	return 0;
+}
+
+static int rtk_dai_i2s_prepare(struct snd_pcm_substream *substream,
+			       struct snd_soc_dai *dai)
+{
+	struct rtk_afe_priv *afe = snd_soc_dai_get_drvdata(dai);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct rpc_ringbuffer_header ring_header = {0};
+	struct rtk_dai_i2s_priv *i2s_priv;
+	int ret;
+
+	i2s_priv = afe->dai_priv[dai->id];
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		ring_header.instance_id = i2s_priv->ai_id;
+		ring_header.pin_id = PCM_OUT;
+		ring_header.read_idx = -1;
+		ret = rtk_snd_prepare_ringbuf(afe, NULL, RTK_ENC_AI_BUFFER_SIZE,
+					      runtime->channels,
+					      &i2s_priv->airing, &ring_header,
+					      RTK_ACPU_FLAGS);
+		if (ret)
+			goto err_alloc_ringbuf;
+
+		ret = rpc_config_i2s_in(&afe->rpc_priv, i2s_priv->ai_id);
+		if (ret)
+			goto err_send_rpc;
+	}
+	return 0;
+
+err_send_rpc:
+err_alloc_ringbuf:
+	rtk_snd_free_ringbuf(&i2s_priv->airing);
+	return ret;
+}
+
+static const struct snd_soc_dai_ops rtk_dai_i2s_ops = {
+	.startup	= rtk_dai_i2s_startup,
+	.hw_params	= rtk_dai_i2s_hw_params,
+	.hw_free	= rtk_dai_i2s_hw_free,
+	.prepare	= rtk_dai_i2s_prepare,
+};
+
+static struct snd_soc_dai_driver rtk_dai_i2s_driver[] = {
+	{
+		.name = "I2S0",
+		.id = RTK_DAI_I2S_0,
+		.playback = {
+			.stream_name = "I2S0_OUT",
+			.channels_min = 1,
+			.channels_max = 8,
+			.rates = RTK_I2S_RATES,
+			.formats = RTK_I2S_FORMATS,
+		},
+		.capture = {
+			.stream_name = "I2S0_IN",
+			.channels_min = 1,
+			.channels_max = 8,
+			.rates = RTK_I2S_RATES,
+			.formats = RTK_I2S_FORMATS,
+		},
+		.ops = &rtk_dai_i2s_ops,
+	},
+	{
+		.name = "I2S1",
+		.id = RTK_DAI_I2S_1,
+		.capture = {
+			.stream_name = "I2S1",
+			.channels_min = 1,
+			.channels_max = 8,
+			.rates = RTK_I2S_RATES,
+			.formats = RTK_I2S_FORMATS,
+		},
+		.ops = &rtk_dai_i2s_ops,
+	},
+};
+
+static int init_i2s_priv_data(struct rtk_afe_priv *afe)
+{
+	struct rtk_dai_i2s_priv *i2s_priv;
+	int i;
+
+	for (i = RTK_DAI_I2S_START; i < RTK_DAI_I2S_END; i++) {
+		i2s_priv = devm_kzalloc(afe->dev,
+					sizeof(struct rtk_dai_i2s_priv),
+					GFP_KERNEL);
+		if (!i2s_priv)
+			return -ENOMEM;
+
+		afe->dai_priv[i] = i2s_priv;
+	}
+	return 0;
+}
+
+int rtk_dai_i2s_register(struct rtk_afe_priv *afe)
+{
+	struct rtk_afe_dai *dai;
+
+	dai = devm_kzalloc(afe->dev, sizeof(*dai), GFP_KERNEL);
+	if (!dai)
+		return -ENOMEM;
+
+	list_add(&dai->list, &afe->sub_dais);
+
+	dai->dai_drivers = rtk_dai_i2s_driver;
+	dai->num_dai_drivers = ARRAY_SIZE(rtk_dai_i2s_driver);
+	dai->dapm_routes = rtk_dai_i2s_routes;
+	dai->num_dapm_routes = ARRAY_SIZE(rtk_dai_i2s_routes);
+
+	return init_i2s_priv_data(afe);
+}
diff --git a/sound/soc/realtek/rtk-hifi-machine.c b/sound/soc/realtek/rtk-hifi-machine.c
index c981dc5ed110..752371939194 100644
--- a/sound/soc/realtek/rtk-hifi-machine.c
+++ b/sound/soc/realtek/rtk-hifi-machine.c
@@ -15,22 +15,21 @@
 #include <sound/jack.h>
 #include "../codecs/rt5645.h"
 
-#define RT5650_CODEC_DAI1	"rt5645-aif1"
-#define RT5650_CODEC_DAI2	"rt5645-aif2"
-
 #define DP_CODEC_DAI	"spdif-hifi"
 #define HDMI_CODEC_DAI	"spdif-hifi"
 
 enum {
-	DAI_LINK_SOF_RDL2_BE = 0,
-	DAI_LINK_SOF_RUL4_BE,
-	DAI_LINK_DL1_BE,
-	DAI_LINK_UL1_BE,
-	DAI_LINK_DL1_FE,
-	DAI_LINK_I2S_RT5650,
+	DAI_LINK_DL1_FE = 0,
+	DAI_LINK_DL2_FE,
+	DAI_LINK_DL3_FE,
+	DAI_LINK_UL1_FE,
+	DAI_LINK_UL2_FE,
+	DAI_LINK_I2S,
+	DAI_LINK_I2S_LOOPBACK,
+	DAI_LINK_AO0_BE,
 	DAI_LINK_DMIC_BE,
 	DAI_LINK_DP_AUDIO_BE,
-	DAI_LINK_HDMI_AUDIO_BE
+	DAI_LINK_HDMI_AUDIO_BE,
 };
 
 struct rtk_soc_card_data {
@@ -44,14 +43,24 @@ SND_SOC_DAILINK_DEFS(DL1_FE,
 		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
 		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
 
-SND_SOC_DAILINK_DEFS(RDAI_I2S1, DAILINK_COMP_ARRAY(COMP_CPU("SOF_DL2")),
-		     DAILINK_COMP_ARRAY(COMP_CODEC(NULL,
-						RT5650_CODEC_DAI2)),
+SND_SOC_DAILINK_DEFS(DL2_FE,
+		     DAILINK_COMP_ARRAY(COMP_CPU("DL2")),
+		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
+		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
+
+SND_SOC_DAILINK_DEFS(DL3_FE,
+		     DAILINK_COMP_ARRAY(COMP_CPU("DL3")),
+		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
+		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
+
+SND_SOC_DAILINK_DEFS(UL1_FE,
+		     DAILINK_COMP_ARRAY(COMP_CPU("UL1")),
+		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
 		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
 
-SND_SOC_DAILINK_DEFS(RDAI_I2S0, DAILINK_COMP_ARRAY(COMP_CPU("SOF_UL4")),
-		     DAILINK_COMP_ARRAY(COMP_CODEC(NULL,
-						RT5650_CODEC_DAI1)),
+SND_SOC_DAILINK_DEFS(UL2_FE,
+		     DAILINK_COMP_ARRAY(COMP_CPU("UL2")),
+		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
 		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
 
 SND_SOC_DAILINK_DEFS(HDMI_AO, DAILINK_COMP_ARRAY(COMP_CPU("SOF_HDMI")),
@@ -62,107 +71,32 @@ SND_SOC_DAILINK_DEFS(DP_AO, DAILINK_COMP_ARRAY(COMP_CPU("SOF_DP")),
                      DAILINK_COMP_ARRAY(COMP_DUMMY()),
 		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
 /* BE */
-SND_SOC_DAILINK_DEFS(i2s0,
+SND_SOC_DAILINK_DEFS(I2S0,
 		     DAILINK_COMP_ARRAY(COMP_CPU("I2S0")),
 		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
 		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
 
-SND_SOC_DAILINK_DEFS(i2s1,
-		     DAILINK_COMP_ARRAY(COMP_CPU("I2S1")),
+SND_SOC_DAILINK_DEFS(I2S0_LOOPBACK,
+		     DAILINK_COMP_ARRAY(COMP_CPU("I2S0_LOOPBACK")),
 		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
 		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
 
-SND_SOC_DAILINK_DEFS(i2s0_rt5650,
-		     DAILINK_COMP_ARRAY(COMP_CPU("I2S0")),
-		     DAILINK_COMP_ARRAY(COMP_CODEC(NULL,
-						   RT5650_CODEC_DAI1)),
-		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
-
 SND_SOC_DAILINK_DEFS(DMIC_PDM,
 		     DAILINK_COMP_ARRAY(COMP_CPU("SOF_DMIC")),
 		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
 		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
 
+SND_SOC_DAILINK_DEFS(AUDIO_OUT0,
+		     DAILINK_COMP_ARRAY(COMP_CPU("AUDIO_OUT0")),
+		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
+		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
+
 static int rtk_sof_be_hw_params(struct snd_pcm_substream *substream,
 				struct snd_pcm_hw_params *params)
 {
 	return 0;
 }
 
-static int rtk_rt5650_i2s_hw_params(struct snd_pcm_substream *substream,
-				    struct snd_pcm_hw_params *params)
-{
-	struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
-//	struct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);
-	struct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);
-	int ret = 0;
-	int mclk;
-
-	switch (params_rate(params)) {
-	case 8000:
-	case 16000:
-	case 24000:
-	case 32000:
-	case 48000:
-	case 64000:
-	case 96000:
-		mclk = 24576000;
-		break;
-	case 11025:
-	case 22050:
-	case 44100:
-	case 88200:
-		mclk = 22579200;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	ret = snd_soc_dai_set_sysclk(codec_dai, 0, mclk,
-				     SND_SOC_CLOCK_IN);
-	if (ret < 0) {
-		dev_err(codec_dai->dev, "Can't set codec clock %d\n", ret);
-		return ret;
-	}
-
-	return ret;
-}
-
-static struct snd_soc_jack rtk_rt5650_jack;
-
-static int rtk_rt5650_init(struct snd_soc_pcm_runtime *runtime)
-{
-	struct snd_soc_card *card = runtime->card;
-	struct snd_soc_component *component = asoc_rtd_to_codec(runtime, 0)->component;
-	int ret;
-	int type =	SND_JACK_HEADPHONE | SND_JACK_MICROPHONE |
-				SND_JACK_BTN_0 | SND_JACK_BTN_1 |
-				SND_JACK_BTN_2 | SND_JACK_BTN_3;
-
-	rt5645_sel_asrc_clk_src(component,
-				RT5645_DA_STEREO_FILTER |
-				RT5645_AD_STEREO_FILTER,
-				RT5645_CLK_SEL_I2S1_ASRC);
-
-	/* enable jack detection */
-	ret = snd_soc_card_jack_new(card, "Headphone Jack",
-				    type,
-				    &rtk_rt5650_jack);
-
-	if (ret) {
-		dev_err(card->dev, "Can't new Headphone Jack %d\n", ret);
-		return ret;
-	}
-
-	ret = snd_soc_component_set_jack(component, &rtk_rt5650_jack, &type);
-	if (ret) {
-		dev_err(card->dev,"comp set jack FAIL\n");
-	}
-
-	return ret;
-
-}
-
 static struct snd_soc_jack rtk_hdmi_jack;
 static int rtk_hdmi_codec_init(struct snd_soc_pcm_runtime *rtd)
 {
@@ -215,32 +149,7 @@ static const struct snd_soc_ops rtk_sof_be_ops = {
 	.hw_params = rtk_sof_be_hw_params,
 };
 
-static const struct snd_soc_ops rtk_rt5650_i2s_ops = {
-	.hw_params = rtk_rt5650_i2s_hw_params,
-};
-
 static struct snd_soc_dai_link rtk_hifi_dai_links[] = {
-	[DAI_LINK_SOF_RDL2_BE] = {
-		.name = "RDAI_I2S1",
-		.no_pcm = 1,
-		.dpcm_playback = 1,
-		//.dpcm_capture = 1,
-		.ops = &rtk_rt5650_i2s_ops,
-		.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
-			SND_SOC_DAIFMT_CBS_CFS,
-		SND_SOC_DAILINK_REG(RDAI_I2S1),
-	},
-	[DAI_LINK_SOF_RUL4_BE] = {
-		.name = "RDAI_I2S",
-		.no_pcm = 1,
-		.dpcm_playback = 1,
-		.dpcm_capture = 1,
-		.init = rtk_rt5650_init,
-		.ops = &rtk_rt5650_i2s_ops,
-		.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
-			SND_SOC_DAIFMT_CBS_CFS,
-		SND_SOC_DAILINK_REG(RDAI_I2S0),
-	},
 	[DAI_LINK_DMIC_BE] = {
 		.name = "RDAI_DMIC",
 		.no_pcm = 1,
@@ -259,40 +168,78 @@ static struct snd_soc_dai_link rtk_hifi_dai_links[] = {
 		.dpcm_playback = 1,
 		SND_SOC_DAILINK_REG(DP_AO),
 	},
-	[DAI_LINK_DL1_BE] = {
-		.name = "RDAI_SOC_DL1",
+	[DAI_LINK_AO0_BE] = {
+		.name = "RDAI_SOC_AO0",
 		.no_pcm = 1,
 		.dpcm_playback = 1,
-		.ops = &rtk_sof_be_ops,
-		SND_SOC_DAILINK_REG(i2s0),
+		SND_SOC_DAILINK_REG(AUDIO_OUT0),
+	},
+	[DAI_LINK_I2S] = {
+		.name = "RDAI_SOC_I2S",
+		.no_pcm = 1,
+		.dpcm_capture = 1,
+		SND_SOC_DAILINK_REG(I2S0),
 	},
-	[DAI_LINK_UL1_BE] = {
-		.name = "RDAI_SOC_UL1",
+	[DAI_LINK_I2S_LOOPBACK] = {
+		.name = "RDAI_SOC_I2S0_LOOPBACK",
 		.no_pcm = 1,
 		.dpcm_capture = 1,
-		.ops = &rtk_sof_be_ops,
-		SND_SOC_DAILINK_REG(i2s1),
+		SND_SOC_DAILINK_REG(I2S0_LOOPBACK),
 	},
 	[DAI_LINK_DL1_FE] = {
 		.name = "RDAI_DL1_FE",
-		.stream_name = "DL2 Playback",
+		.stream_name = "DL1 Playback",
 		.trigger = {
 			SND_SOC_DPCM_TRIGGER_POST,
 			SND_SOC_DPCM_TRIGGER_POST,
 		},
 		.dynamic = 1,
 		.dpcm_playback = 1,
-		.dpcm_capture = 1,
 		SND_SOC_DAILINK_REG(DL1_FE),
 	},
-	[DAI_LINK_I2S_RT5650] = {
-		.name = "RDAI_I2S_RT5650",
-		.no_pcm = 1,
+	[DAI_LINK_DL2_FE] = {
+		.name = "RDAI_DL2_FE",
+		.stream_name = "DL2 Playback",
+		.trigger = {
+			SND_SOC_DPCM_TRIGGER_POST,
+			SND_SOC_DPCM_TRIGGER_POST,
+		},
+		.dynamic = 1,
+		.dpcm_playback = 1,
+		SND_SOC_DAILINK_REG(DL2_FE),
+	},
+	[DAI_LINK_DL3_FE] = {
+		.name = "RDAI_DL3_FE",
+		.stream_name = "DL3 Playback",
+		.trigger = {
+			SND_SOC_DPCM_TRIGGER_POST,
+			SND_SOC_DPCM_TRIGGER_POST,
+		},
+		.dynamic = 1,
 		.dpcm_playback = 1,
-		.ops = &rtk_rt5650_i2s_ops,
-		.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
-			SND_SOC_DAIFMT_CBS_CFS,
-		SND_SOC_DAILINK_REG(i2s0_rt5650),
+		SND_SOC_DAILINK_REG(DL3_FE),
+	},
+	[DAI_LINK_UL1_FE] = {
+		.name = "RDAI_UL1_FE",
+		.stream_name = "UL1 Capture",
+		.trigger = {
+			SND_SOC_DPCM_TRIGGER_POST,
+			SND_SOC_DPCM_TRIGGER_POST,
+		},
+		.dynamic = 1,
+		.dpcm_capture = 1,
+		SND_SOC_DAILINK_REG(UL1_FE),
+	},
+	[DAI_LINK_UL2_FE] = {
+		.name = "RDAI_UL2_FE",
+		.stream_name = "UL2 Capture",
+		.trigger = {
+			SND_SOC_DPCM_TRIGGER_POST,
+			SND_SOC_DPCM_TRIGGER_POST,
+		},
+		.dynamic = 1,
+		.dpcm_capture = 1,
+		SND_SOC_DAILINK_REG(UL2_FE),
 	},
 };
 
@@ -347,7 +294,7 @@ int rtk_soc_dailink_parse_of(struct snd_soc_card *card, struct device_node *np,
 		dev_err(dev, "number of dai-link is invalid %d\n", num_links);
 		return -EINVAL;
 	}
-	
+
 	parsed_dai_link = devm_kcalloc(dev, num_links, sizeof(*parsed_dai_link),
 				       GFP_KERNEL);
 	if (!parsed_dai_link)
@@ -371,10 +318,10 @@ int rtk_soc_dailink_parse_of(struct snd_soc_card *card, struct device_node *np,
 			}
 		}
 	}
-	
+
 	if (parsed_num_links != num_links)
 		return -EINVAL;
-	
+
 	card->dai_link = parsed_dai_link;
 	card->num_links = parsed_num_links;
 
@@ -442,9 +389,7 @@ static int rtk_hifi_dev_probe(struct platform_device *pdev)
 	/* assign the node of sof driver to platforms in dai_link */
 	for_each_card_prelinks(card, i, dai_link) {
 		dai_link->platforms->of_node = platform_node;
-		if (strcmp(dai_link->name, "RDAI_I2S_RT5650") == 0) {
-			dai_link->codecs->of_node = of_parse_phandle(dev->of_node, "realtek,audio-codec", 0);
-		} else if (strcmp(dai_link->name, "RDAI_I2S") == 0 ||
+		if (strcmp(dai_link->name, "RDAI_I2S") == 0 ||
 			   strcmp(dai_link->name, "RDAI_I2S1") == 0) {
 			card->dapm_routes = NULL;
 			card->num_dapm_routes = 0;//ARRAY_SIZE(rtk_hifi_routes),
@@ -469,6 +414,9 @@ static int rtk_hifi_dev_probe(struct platform_device *pdev)
 				dai_link->init = rtk_dp_codec_init;
                         } else
 				pr_info("Cant find CODEC,RDAI_DP use DUMMY CODEC");
+		} else if (strcmp(dai_link->name, "RDAI_SOC_AO0") == 0) {
+			card->dapm_routes = NULL;
+			card->num_dapm_routes = 0;//ARRAY_SIZE(rtk_hifi_routes),
 		}
 	}
 
@@ -498,6 +446,9 @@ static const struct of_device_id rtk_hifi_dt_match[] = {
 	{
 		.compatible = "realtek,rtd1920s-hifi-mc",
 	},
+	{
+		.compatible = "realtek,rtd1619b-hifi-mc",
+	},
 	{},
 };
 
diff --git a/sound/soc/realtek/rtk-hifi-rpc.c b/sound/soc/realtek/rtk-hifi-rpc.c
new file mode 100644
index 000000000000..54ae21afdacc
--- /dev/null
+++ b/sound/soc/realtek/rtk-hifi-rpc.c
@@ -0,0 +1,471 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (c) 2017-2020 Realtek Semiconductor Corp.
+ */
+
+#include "rtk-hifi-rpc.h"
+
+static int rpc_hifi_cb(struct rtk_krpc_ept_info *ept, char *buf)
+{
+	u32 *tmp;
+	struct rpc_struct *rpc = (struct rpc_struct *)buf;
+
+	if (rpc->programID == REPLYID) {
+		tmp = (u32 *)(buf + sizeof(struct rpc_struct));
+		*(ept->retval) = *(tmp + 1);
+
+		complete(&ept->ack);
+	}
+	return 0;
+}
+
+static int send_rpc(struct rtk_rpc_priv *priv, u32 *retval)
+{
+	struct rtk_krpc_ept_info *ept = priv->ept;
+	char *buf;
+	int ret = 0;
+
+	ept->retval = retval;
+	buf = (char *)&priv->data;
+	ret = rtk_send_rpc(ept, buf, sizeof(struct rpc_data));
+	if (ret < 0) {
+		pr_err("[%s] send rpc failed\n", ept->name);
+		return ret;
+	}
+
+	if (!wait_for_completion_timeout(&ept->ack, RPC_TIMEOUT)) {
+		pr_err("[%s] kernel rpc timeout\n", ept->name);
+		rtk_krpc_dump_ringbuf_info(ept);
+		WARN_ON(1);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static void rpc_set_channel_map(int ch, char *p)
+{
+	switch (ch) {
+	case 1:
+		p[0] = ENUM_AUDIO_LEFT_FRONT_INDEX;
+		break;
+	case 2:
+		p[0] = ENUM_AUDIO_LEFT_FRONT_INDEX;
+		p[1] = ENUM_AUDIO_RIGHT_FRONT_INDEX;
+		break;
+	case 3:
+		p[0] = ENUM_AUDIO_LEFT_FRONT_INDEX;
+		p[1] = ENUM_AUDIO_RIGHT_FRONT_INDEX;
+		p[2] = ENUM_AUDIO_CENTER_FRONT_INDEX;
+		break;
+	case 4:
+		p[0] = ENUM_AUDIO_LEFT_FRONT_INDEX;
+		p[1] = ENUM_AUDIO_RIGHT_FRONT_INDEX;
+		p[2] = ENUM_AUDIO_LEFT_SURROUND_REAR_INDEX;
+		p[3] = ENUM_AUDIO_RIGHT_SURROUND_REAR_INDEX;
+		break;
+	case 5:
+		p[0] = ENUM_AUDIO_LEFT_FRONT_INDEX;
+		p[1] = ENUM_AUDIO_RIGHT_FRONT_INDEX;
+		p[2] = ENUM_AUDIO_CENTER_FRONT_INDEX;
+		p[3] = ENUM_AUDIO_LEFT_SURROUND_REAR_INDEX;
+		p[4] = ENUM_AUDIO_RIGHT_SURROUND_REAR_INDEX;
+		break;
+	case 6:
+		p[0] = ENUM_AUDIO_LEFT_FRONT_INDEX;
+		p[1] = ENUM_AUDIO_RIGHT_FRONT_INDEX;
+		p[2] = ENUM_AUDIO_CENTER_FRONT_INDEX;
+		p[3] = ENUM_AUDIO_LFE_INDEX;
+		p[4] = ENUM_AUDIO_LEFT_SURROUND_REAR_INDEX;
+		p[5] = ENUM_AUDIO_RIGHT_SURROUND_REAR_INDEX;
+		break;
+	case 7:
+	case 8:
+		p[0] = ENUM_AUDIO_LEFT_FRONT_INDEX;
+		p[1] = ENUM_AUDIO_RIGHT_FRONT_INDEX;
+		p[2] = ENUM_AUDIO_CENTER_FRONT_INDEX;
+		p[3] = ENUM_AUDIO_LFE_INDEX;
+		p[4] = ENUM_AUDIO_LEFT_SURROUND_REAR_INDEX;
+		p[5] = ENUM_AUDIO_RIGHT_SURROUND_REAR_INDEX;
+		p[6] = ENUM_AUDIO_LEFT_OUTSIDE_FRONT_INDEX;
+		p[7] = ENUM_AUDIO_RIGHT_OUTSIDE_FRONT_INDEX;
+		break;
+	default:
+		pr_err("channel not support %d\n", ch);
+		break;
+	}
+}
+
+int init_ringbuf_header_ptrs(struct ringbuf_header_ptrs *ptrs,
+			     void *base, bool cacheable)
+{
+	int size;
+
+	if (!cacheable) {
+		ptrs->p_magic = base + 0;
+		ptrs->p_begin_addr = base + 4;
+		ptrs->p_size = base + 8;
+		ptrs->p_buffer_id = base + 12;
+		ptrs->p_write_ptr = base + 16;
+		ptrs->p_num_read_ptr = base + 20;
+		ptrs->p_read_ptr = base + 32;
+		ptrs->p_file_offset = base + 48;
+		ptrs->p_requested_file_offset = base + 52;
+		ptrs->p_file_size = base + 56;
+		ptrs->p_seekable = base + 60;
+		ptrs->p_latency = base + SHMEM_OFFSET;
+		size = 512;
+	} else {
+		ptrs->p_magic = base + 256;
+		ptrs->p_begin_addr = base + 260;
+		ptrs->p_size = base + 264;
+		ptrs->p_buffer_id = base + 268;
+		ptrs->p_write_ptr = base + 0;
+		ptrs->p_num_read_ptr = base + 272;
+		ptrs->p_read_ptr = base + 128;
+		ptrs->p_file_offset = base + 284;
+		ptrs->p_requested_file_offset = base + 288;
+		ptrs->p_file_size = base + 292;
+		ptrs->p_seekable = base + 296;
+		ptrs->p_latency = base + SHMEM_OFFSET;
+		size = 512;
+	}
+	return size;
+}
+
+int rpc_send_command(struct rtk_rpc_priv *priv, char *rpc_src, size_t size,
+		     struct rpc_result *result, int cmd)
+{
+	char *rpc;
+	struct rpc_result *retval;
+	int ret = -1, rpc_ret, offset;
+
+	mutex_lock(&priv->ept->send_mutex);
+
+	rpc = (char *)priv->vaddr;
+	memset(rpc, 0, size);
+	offset = ALIGN(size, 128);
+	retval = (struct rpc_result *)(rpc + offset);
+	memset(retval, 0, sizeof(*retval));
+
+	memcpy(rpc, rpc_src, size);
+	priv->data.command = cmd;
+	priv->data.param2 =  priv->paddr + offset;
+
+	if (send_rpc(priv, &rpc_ret)) {
+		pr_err("[%s] fail, cmd(%d)\n", __func__, cmd);
+		goto exit;
+	}
+	if (rpc_ret != S_OK || (result && retval->result != S_OK)) {
+		pr_err("[%s] ret fail, cmd(%d)\n", __func__, cmd);
+		goto exit;
+	}
+	if (result)
+		memcpy(result, retval, sizeof(*result));
+	ret = 0;
+exit:
+	mutex_unlock(&priv->ept->send_mutex);
+	return ret;
+}
+
+int rpc_send_private(struct rtk_rpc_priv *priv,
+		     struct rpc_privateinfo_param *param,
+		     struct rpc_privateinfo_result *result,
+		     int cmd)
+{
+	struct rpc_privateinfo_param *rpc;
+	struct rpc_privateinfo_result *retval;
+	int ret = -1, rpc_ret, offset;
+
+	mutex_lock(&priv->ept->send_mutex);
+
+	rpc = (struct rpc_privateinfo_param *)priv->vaddr;
+	memset(rpc, 0, sizeof(*rpc));
+	offset = ALIGN(sizeof(*rpc), 128);
+	retval = (struct rpc_privateinfo_result *)((char *)rpc + offset);
+	memset(retval, 0, sizeof(*retval));
+
+	memcpy(rpc, param, sizeof(*rpc));
+	priv->data.command = cmd;
+	priv->data.param2 =  priv->paddr + offset;
+
+	if (send_rpc(priv, &rpc_ret)) {
+		pr_err("[%s] fail, type(%d)\n", __func__, rpc->type);
+		goto exit;
+	}
+	if (rpc_ret != S_OK) {
+		pr_err("[%s] ret fail, type(%x)\n", __func__, rpc->type);
+		goto exit;
+	}
+
+	if (result)
+		memcpy(result, retval, sizeof(*result));
+	ret = 0;
+exit:
+	mutex_unlock(&priv->ept->send_mutex);
+	return ret;
+}
+
+int rpc_create_audio_agent(struct rtk_rpc_priv *priv, int pin, int *ao_id)
+{
+	struct rpc_create_ao_agent rpc = {0};
+	struct rpc_result result = {0};
+	int ret;
+
+	rpc.instance_id = 0;
+	rpc.type = pin;
+
+	ret = rpc_send_command(priv, (char *)&rpc, sizeof(rpc), &result,
+			       ENUM_KERNEL_RPC_CREATE_AGENT);
+	if (!ret)
+		*ao_id = result.data;
+
+	pr_info("[audio rpc] %s\n", __func__);
+	return ret;
+}
+
+int rpc_init_ringbuffer_header(struct rtk_rpc_priv *priv,
+			       struct rpc_ringbuffer_header *rpc)
+{
+	pr_info("[audio rpc] %s\n", __func__);
+	return rpc_send_command(priv, (char *)rpc, sizeof(*rpc), NULL,
+				ENUM_KERNEL_RPC_INIT_RINGBUF);
+}
+
+int rpc_put_shmem_latency(struct rtk_rpc_priv *priv, int ao_id, int pin, void *p)
+{
+	struct rpc_privateinfo_param rpc = {0};
+
+	rpc.instance_id = ao_id;
+	rpc.type = ENUM_PRIVATEINFO_AUDIO_GET_SHARE_MEMORY_FROM_ALSA;
+	rpc.private_info[0] = 0;
+	rpc.private_info[1] = 2379;
+	rpc.private_info[2] = (u32)(long)p;
+	rpc.private_info[3] = 0;
+	rpc.private_info[4] = ao_id;
+
+	pr_info("[audio rpc] %s\n", __func__);
+	return rpc_send_private(priv, &rpc, NULL, ENUM_KERNEL_RPC_PRIVATEINFO);
+}
+
+int rpc_pause_svc(struct rtk_rpc_priv *priv, int id)
+{
+	pr_info("[audio rpc] %s\n", __func__);
+	return rpc_send_command(priv, (char *)&id, sizeof(id), NULL,
+				ENUM_KERNEL_RPC_PAUSE);
+}
+
+int rpc_run_svc(struct rtk_rpc_priv *priv, int id)
+{
+	struct rpc_result result = {0};
+
+	pr_info("[audio rpc] %s\n", __func__);
+	return rpc_send_command(priv, (char *)&id, sizeof(id), &result,
+				ENUM_KERNEL_RPC_RUN);
+}
+
+int rpc_stop_svc(struct rtk_rpc_priv *priv, int id)
+{
+	struct rpc_result result = {0};
+
+	pr_info("[audio rpc] %s\n", __func__);
+	return rpc_send_command(priv, (char *)&id, sizeof(id), &result,
+				ENUM_KERNEL_RPC_STOP);
+}
+
+int rpc_config_i2s_in(struct rtk_rpc_priv *priv, int ai_id)
+{
+	struct rpc_privateinfo_param rpc = {0};
+
+	rpc.instance_id = ai_id;
+	rpc.type = ENUM_PRIVATEINFO_AUDIO_AI_PAD_IN;
+	rpc.private_info[0] = 48000;
+	rpc.private_info[1] = 0x11224466;
+	rpc.private_info[2] = 0;
+
+	pr_info("[audio rpc] %s\n", __func__);
+	return rpc_send_private(priv, &rpc, NULL, ENUM_KERNEL_RPC_PRIVATEINFO);
+}
+
+int rpc_config_loopback_in(struct rtk_rpc_priv *priv, int ai_id)
+{
+	struct rpc_privateinfo_param rpc = {0};
+
+	rpc.instance_id = ai_id;
+	rpc.type = ENUM_PRIVATEINFO_AIO_AI_LOOPBACK_AO;
+	rpc.private_info[0] |= 1 << ENUM_RPC_AI_LOOPBACK_FROM_AO_I2S;
+
+	pr_info("[audio rpc] %s\n", __func__);
+	return rpc_send_private(priv, &rpc, NULL, ENUM_KERNEL_RPC_AIO_PRIVATEINFO);
+}
+
+int rpc_ai_connect_alsa(struct rtk_rpc_priv *priv,
+			struct snd_pcm_runtime *runtime, int ai_id)
+{
+	struct rpc_privateinfo_param rpc = {0};
+	int ai_format;
+
+	switch (runtime->access) {
+	case SNDRV_PCM_ACCESS_MMAP_INTERLEAVED:
+	case SNDRV_PCM_ACCESS_RW_INTERLEAVED:
+		switch (runtime->format) {
+		case SNDRV_PCM_FORMAT_S16_LE:
+			ai_format = AUDIO_ALSA_FORMAT_16BITS_LE_LPCM;
+			break;
+		case SNDRV_PCM_FORMAT_S24_LE:
+			ai_format = AUDIO_ALSA_FORMAT_24BITS_LE_LPCM;
+			break;
+		case SNDRV_PCM_FORMAT_S24_3LE:
+			ai_format = AUDIO_ALSA_FORMAT_24BITS_LE_LPCM;
+			break;
+		case SNDRV_PCM_FORMAT_S32_LE:
+			ai_format = AUDIO_ALSA_FORMAT_32BITS_LE_LPCM;
+			break;
+		default:
+			pr_err("[%s] unsupport format, 0x%x\n", __func__,
+				runtime->format);
+			return -1;
+		}
+		break;
+	case SNDRV_PCM_ACCESS_MMAP_NONINTERLEAVED:
+	case SNDRV_PCM_ACCESS_RW_NONINTERLEAVED:
+	default:
+		pr_err("[%s] unsupport access\n", __func__);
+		return -1;
+	}
+
+	rpc.instance_id = ai_id;
+	rpc.type = ENUM_PRIVATEINFO_AUDIO_AI_CONNECT_ALSA;
+	rpc.private_info[0] = ai_format;
+	rpc.private_info[1] = runtime->rate;
+	rpc.private_info[3] = runtime->channels;
+
+	pr_info("[audio rpc] %s\n", __func__);
+	return rpc_send_private(priv, &rpc, NULL, ENUM_KERNEL_RPC_PRIVATEINFO);
+}
+
+int rpc_destroy_ai_flow(struct rtk_rpc_priv *priv, int ai_id, int configured)
+{
+	struct rpc_privateinfo_param rpc = {0};
+
+	rpc.instance_id = ai_id;
+	rpc.type = ENUM_PRIVATEINFO_AIO_ALSA_DESTROY_AI_FLOW;
+	if (configured == 0)
+		rpc.private_info[0] = 0x23792379;
+
+	pr_info("[audio rpc] %s\n", __func__);
+	return rpc_send_private(priv, &rpc, NULL, ENUM_KERNEL_RPC_AIO_PRIVATEINFO);
+}
+
+int rpc_get_ao_flash_pin(struct rtk_rpc_priv *priv, int ao_id, int *pin)
+{
+	struct rpc_privateinfo_param rpc = {0};
+	struct rpc_privateinfo_result result = {0};
+	int i, ret;
+
+	rpc.instance_id = ao_id;
+	rpc.type = ENUM_PRIVATEINFO_AUDIO_GET_FLASH_PIN;
+	for (i = 0; i < 6; i++)
+		rpc.private_info[i] = 0xff;
+
+	pr_info("[audio rpc] %s\n", __func__);
+	ret = rpc_send_private(priv, &rpc, &result,
+			       ENUM_KERNEL_RPC_PRIVATEINFO);
+	if (!ret)
+		*pin = result.private_info[0];
+
+	return ret;
+}
+
+int rpc_get_chache_config(struct rtk_rpc_priv *priv, int *cacheable)
+{
+	struct rpc_privateinfo_param rpc = {0};
+	struct rpc_privateinfo_result result = {0};
+	int ret;
+
+	pr_info("[audio rpc] %s\n", __func__);
+
+	ret = rpc_send_private(priv, &rpc, &result, ENUM_KERNEL_RPC_GET_CACHE_CONFIG);
+
+	if (!ret)
+		*cacheable = result.private_info[0];
+
+	return ret;
+}
+
+int rpc_put_ao_flash_pin(struct rtk_rpc_priv *priv, int ao_id, int *pin)
+{
+	struct rpc_privateinfo_param rpc = {0};
+	int i, ret;
+
+	rpc.instance_id = ao_id;
+	rpc.type = ENUM_PRIVATEINFO_AUDIO_RELEASE_FLASH_PIN;
+	rpc.private_info[0] = *pin;
+	for (i = 1; i < 6; i++)
+		rpc.private_info[i] = 0xff;
+
+	pr_info("[audio rpc] %s\n", __func__);
+	ret = rpc_send_private(priv, &rpc, NULL, ENUM_KERNEL_RPC_PRIVATEINFO);
+	if (!ret)
+		*pin = 0;
+	return ret;
+}
+
+int rpc_config_ao(struct rtk_rpc_priv *priv, int ao_id, int pin,
+		  struct snd_pcm_runtime *runtime)
+{
+	struct rpc_privateinfo_param rpc = {0};
+
+	rpc.instance_id = ao_id;
+	rpc.type = ENUM_PRIVATEINFO_AIO_AO_FLASH_LPCM;
+	rpc.private_info[1] = pin | ((runtime->sample_bits >> 3) << 8) |
+				AUDIO_LITTLE_ENDIAN << 16;
+
+	rpc.private_info[2] = runtime->rate;
+	rpc_set_channel_map(runtime->channels, (char *)&rpc.private_info[3]);
+
+	rpc.private_info[5] = (15 << 16);
+	rpc.private_info[5] |= 20;
+
+	pr_info("[audio rpc] %s\n", __func__);
+	return rpc_send_private(priv, &rpc, NULL, ENUM_KERNEL_RPC_AIO_PRIVATEINFO);
+}
+
+int rpc_ctrl_aio(struct rtk_rpc_priv *priv, int ao_id, struct rpc_aio_ctrl *ctrl)
+{
+	struct rpc_privateinfo_param rpc = {0};
+
+	/* todo hard code private_info[3] now */
+	rpc.instance_id = ao_id;
+	rpc.type = ENUM_PRIVATEINFO_AIO_AO_INTERFACE_SWITCH_CONTROL;
+	rpc.private_info[0] = ctrl->bitmap;
+	rpc.private_info[1] = ctrl->i2s_ch;
+	rpc.private_info[2] = ctrl->i2s_mode;
+	rpc.private_info[3] = AUDIO_OUT;
+
+	pr_info("[audio rpc] %s\n", __func__);
+	return rpc_send_private(priv, &rpc, NULL, ENUM_KERNEL_RPC_AIO_PRIVATEINFO);
+}
+
+int rpc_ept_init(struct rtk_rpc_priv *priv)
+{
+	struct rpc_struct *info;
+	int ret = 0;
+
+	ret = krpc_info_init(priv->ept, "snd", rpc_hifi_cb);
+	if (ret)
+		return ret;
+
+	info = &priv->data.info;
+
+	info->programID = KERNELID;
+	info->versionID = KERNELID;
+	info->procedureID = 0;
+	info->taskID = priv->ept->id;
+	info->sysTID = 0;
+	info->sysPID = 0;
+	info->parameterSize = 3 * sizeof(u32);
+	info->mycontext = 0;
+	priv->data.param1 = priv->paddr;
+
+	return ret;
+}
diff --git a/sound/soc/realtek/rtk-hifi-rpc.h b/sound/soc/realtek/rtk-hifi-rpc.h
new file mode 100644
index 000000000000..ad2a9565e78c
--- /dev/null
+++ b/sound/soc/realtek/rtk-hifi-rpc.h
@@ -0,0 +1,507 @@
+/* SPDX-License-Identifier: GPL-2.0+
+ * Copyright (c) 2017-2020 Realtek Semiconductor Corp.
+ */
+
+#ifndef SND_HIFI_RPC_H
+#define SND_HIFI_RPC_H
+
+#include <sound/pcm.h>
+#include <soc/realtek/rtk-krpc-agent.h>
+
+#define S_OK 0x10000000
+#define SHMEM_OFFSET 384
+
+enum ENUM_AUDIO_KERNEL_RPC_CMD {
+	ENUM_KERNEL_RPC_CREATE_AGENT,   // 0
+	ENUM_KERNEL_RPC_INIT_RINGBUF,
+	ENUM_KERNEL_RPC_PRIVATEINFO,
+	ENUM_KERNEL_RPC_RUN,
+	ENUM_KERNEL_RPC_PAUSE,
+	ENUM_KERNEL_RPC_SWITCH_FOCUS,   // 5
+	ENUM_KERNEL_RPC_MALLOC_ADDR,
+	ENUM_KERNEL_RPC_VOLUME_CONTROL,      // AUDIO_CONFIG_COMMAND
+	ENUM_KERNEL_RPC_FLUSH,               // AUDIO_RPC_SENDIO
+	ENUM_KERNEL_RPC_CONNECT,             // AUDIO_RPC_CONNECTION
+	ENUM_KERNEL_RPC_SETREFCLOCK,    // 10     // AUDIO_RPC_REFCLOCK
+	ENUM_KERNEL_RPC_DAC_I2S_CONFIG,      // AUDIO_CONFIG_DAC_I2S
+	ENUM_KERNEL_RPC_DAC_SPDIF_CONFIG,    // AUDIO_CONFIG_DAC_SPDIF
+	ENUM_KERNEL_RPC_HDMI_OUT_EDID,       // AUDIO_HDMI_OUT_EDID_DATA
+	ENUM_KERNEL_RPC_HDMI_OUT_EDID2,      // AUDIO_HDMI_OUT_EDID_DATA2
+	ENUM_KERNEL_RPC_HDMI_SET,       // 15     // AUDIO_HDMI_SET
+	ENUM_KERNEL_RPC_HDMI_MUTE,           //AUDIO_HDMI_MUTE_INFO
+	ENUM_KERNEL_RPC_ASK_DBG_MEM_ADDR,
+	ENUM_KERNEL_RPC_DESTROY,
+	ENUM_KERNEL_RPC_STOP,
+	ENUM_KERNEL_RPC_CHECK_READY,     // 20    // check if Audio get memory pool from AP
+	ENUM_KERNEL_RPC_GET_MUTE_N_VOLUME,   // get mute and volume level
+	ENUM_KERNEL_RPC_EOS,
+	ENUM_KERNEL_RPC_ADC0_CONFIG,
+	ENUM_KERNEL_RPC_ADC1_CONFIG,
+	ENUM_KERNEL_RPC_ADC2_CONFIG,    // 25
+#if defined(AUDIO_TV_PLATFORM)
+	ENUM_KERNEL_RPC_BBADC_CONFIG,
+	ENUM_KERNEL_RPC_I2SI_CONFIG,
+	ENUM_KERNEL_RPC_SPDIFI_CONFIG,
+#endif // AUDIO_TV_PLATFORM
+	ENUM_KERNEL_RPC_HDMI_OUT_VSDB,
+	ENUM_VIDEO_KERNEL_RPC_CONFIG_TV_SYSTEM,
+	ENUM_VIDEO_KERNEL_RPC_CONFIG_HDMI_INFO_FRAME,
+	ENUM_VIDEO_KERNEL_RPC_QUERY_DISPLAY_WIN,
+	ENUM_VIDEO_KERNEL_RPC_PP_INIT_PIN,
+	ENUM_KERNEL_RPC_INIT_RINGBUF_AO, //need check this enum
+	ENUM_VIDEO_KERNEL_RPC_VOUT_EDID_DATA,
+	ENUM_KERNEL_RPC_AUDIO_POWER_SET,
+	ENUM_VIDEO_KERNEL_RPC_VOUT_VDAC_SET,
+	ENUM_VIDEO_KERNEL_RPC_QUERY_CONFIG_TV_SYSTEM,
+	ENUM_KERNEL_RPC_AUDIO_CONFIG,
+	ENUM_KERNEL_RPC_AIO_PRIVATEINFO,
+	ENUM_KERNEL_RPC_QUERY_FW_DEBUG_INFO,
+	ENUM_KERNEL_RPC_HDMI_RX_LATENCY_MEM,
+	ENUM_KERNEL_RPC_EQ_CONFIG,
+	ENUM_VIDEO_KERNEL_RPC_CREATE,
+	ENUM_VIDEO_KERNEL_RPC_DISPLAY,
+	ENUM_VIDEO_KERNEL_RPC_CONFIGUREDISPLAYWINDOW,
+	ENUM_VIDEO_KERNEL_RPC_SETREFCLOCK,
+	ENUM_VIDEO_KERNEL_RPC_RUN,
+	ENUM_VIDEO_KERNEL_RPC_INITRINGBUFFER,
+	ENUM_VIDEO_KERNEL_RPC_SETRESCALEMODE,
+	ENUM_VIDEO_KERNEL_RPC_SET_HDMI_VRR,
+	ENUM_VIDEO_KERNEL_RPC_CONFIGURE_GRAPHIC_CANVAS,
+	ENUM_VIDEO_KERNEL_RPC_SET_MIXER_ORDER,
+	ENUM_KERNEL_RPC_DEC_PRIVATEINFO,
+	ENUM_KERNEL_RPC_ALSA_FASTER,
+	ENUM_VIDEO_KERNEL_RPC_PAUSE,
+	ENUM_VIDEO_KERNEL_RPC_STOP,
+	ENUM_VIDEO_KERNEL_RPC_DESTROY,
+	ENUM_VIDEO_KERNEL_RPC_FLUSH,
+	ENUM_VIDEO_KERNEL_RPC_Q_PARAMETER,
+	ENUM_VIDEO_KERNEL_RPC_CONFIGCHANNELLOWDELAY,
+	ENUM_VIDEO_KERNEL_RPC_PRIVATEINFO,
+	ENUM_VIDEO_KERNEL_RPC_QUERYDISPLAYWINNEW,
+	ENUM_VIDEO_KERNEL_RPC_SETSPEED,
+	ENUM_VIDEO_KERNEL_RPC_SETBACKGROUND,
+	ENUM_VIDEO_KERNEL_RPC_KEEPCURPIC,
+	ENUM_VIDEO_KERNEL_RPC_KEEPCURPIC_FW_MALLOC,
+	ENUM_VIDEO_KERNEL_RPC_KEEPCURPICSVP,
+	ENUM_VIDEO_KERNEL_RPC_SET_DEINTFLAG,
+	ENUM_VIDEO_KERNEL_RPC_CREATEGRAPHICWINDOW,
+	ENUM_VIDEO_KERNEL_RPC_DRAWGRAPHICWINDOW,
+	ENUM_VIDEO_KERNEL_RPC_MODIFYGRAPHICWINDOW,
+	ENUM_VIDEO_KERNEL_RPC_DELETEGRAPHICWINDOW,
+	ENUM_VIDEO_KERNEL_RPC_CONFIGUREOSDPALETTE,
+	ENUM_VIDEO_KERNEL_RPC_PMIXER_CONFIGUREPLANEMIXER,
+	ENUM_VIDEO_KERNEL_RPC_SET_DISPLAY_OUTPUT_FORMAT,
+	ENUM_VIDEO_KERNEL_RPC_GET_DISPLAY_OUTPUT_FORMAT,
+	ENUM_VIDEO_KERNEL_RPC_SET_ENHANCEDSDR,
+	ENUM_KERNEL_RPC_HDMI_EDID_RAW_DATA,
+	ENUM_VIDEO_KERNEL_RPC_ConfigWriteBackFlow,
+	ENUM_VIDEO_KERNEL_RPC_NPP_Init,
+	ENUM_VIDEO_KERNEL_RPC_NPP_Destroy,
+	ENUM_KERNEL_RPC_AFW_DEBUGLEVEL,
+	ENUM_KERNEL_RPC_DV_ControlPath_Info,
+	ENUM_KERNEL_RPC_GET_AFW_DEBUGLEVEL,
+	ENUM_KERNEL_RPC_ConfigureDisplayWindowDispZoomWinRatio,
+	ENUM_VIDEO_KERNEL_RPC_GET_MIXER_ORDER,
+	ENUM_VIDEO_KERNEL_RPC_SET_DISPLAY_OUTPUT_INTERFACE,
+	ENUM_VIDEO_KERNEL_RPC_GET_DISPLAY_OUTPUT_INTERFACE,
+	ENUM_KERNEL_RPC_SET_BTPCM_CFG,
+	ENUM_KERNEL_RPC_SET_AI_TDM_CFG,
+	ENUM_KERNEL_RPC_EXT_EQ_CONFIG,
+	ENUM_KERNEL_RPC_AUDIO_MULTI_AO_CONFIG,
+	ENUM_KERNEL_RPC_LITE_AO_CREATE,
+	ENUM_KERNEL_RPC_LITE_AO_DESTROY,
+	ENUM_KERNEL_RPC_PARAM_EQ_CONFIG,
+	ENUM_KERNEL_RPC_STEREO_TO_MULTICH_CONFIG,
+	ENUM_KERNEL_RPC_LOUDNESS_CONFIG,
+	ENUM_KERNEL_RPC_GET_CACHE_CONFIG,
+};
+
+enum {
+	ENUM_MEMORY_CFG_UNKNOWN = 0,
+	ENUM_MEMORY_CFG_ALL_CACHE,
+	ENUM_MEMORY_CFG_WITH_UNCACHE,
+};
+
+enum AUDIO_MODULE_TYPE {
+	AUDIO_OUT = 7,
+	AUDIO_IN = 8,
+	AUDIO_ENCODER = 9,
+	AUDIO_MPEG_ENCODER = 10,
+	AUDIO_ALSA_OUT = 12,
+	AUDIO_PSEUDO_OUT = 14,
+	AUDIO_PP_OUT = 15,
+	AUDIO_DECODER = 16,
+	AUDIO_UNKNOWN = 17,
+	AUDIO_LPCM_ENCODER = 19,
+	AUDIO_AAC_ENCODER = 21,
+	AUDIO_MP3_ENCODER = 22,
+	AUDIO_RV_PARSER = 23,
+	AUDIO_AC3_ENCODER = 24,
+	AUDIO_VIENNA_OUT = 25,
+	AUDIO_DTS_ENCODER = 26,
+	AUDIO_VP6_PARSER = 27,
+	AUDIO_IN_DEVICE = 28,
+	AUDIO_ILBC_ENCODER = 29,
+	AUDIO_KARAOKE_MIXER = 30,
+	AUDIO_VP8_PARSER = 31,
+	AUDIO_SILK_ENCODER = 32,
+	AUDIO_G729_ENCODER = 33,
+	AUDIO_PCMU_ENCODER = 34,
+	AUDIO_PCMA_ENCODER = 35,
+	VIDEO_OUT = 36,
+	AUDIO_DDP_ENCODER = 37,
+	AUDIO_MS_PP = 38,
+	AUDIO_MS_DECODER = 39,
+	AUDIO_PRE_PROCESSING = 40,
+	AUDIO_DAP = 41,
+	VIDEO_OUT_SECURE = 42,
+	AUDIO_OUT_SECURE = 43,
+	AUDIO_MAT_ENCODER = 44,
+	VIDEO_OUT_DEINTERLACE_SECURE = 45,
+	VIDEO_OUT_CVBS_SECURE = 46,
+	VIDEO_OUT_KEEPLAST_SECURE = 47,
+	AUDIO_OUT2 = 48,
+};
+
+enum AUDIO_IO_PIN {
+	BASE_BS_IN = 0,
+	EXT_BS_IN = 1,
+	PCM_IN = 2,
+	BASE_BS_OUT = 3,
+	EXT_BS_OUT = 4,
+	PCM_OUT = 5,
+	SPDIF_IN = 6,
+	SPDIF_OUT = 7,
+	NON_PCM_OUT = 8,
+	INBAND_QUEUE = 9,
+	MESSAGE_QUEUE = 10,
+	MIC_IN = 11,
+	SOUND_EVENT_IN = 12,
+	PCM_OUT1 = 13,
+	PCM_OUT2 = 14,
+	FLASH_AUDIO_PIN_1 = 15,
+	FLASH_AUDIO_PIN_2 = 16,
+	FLASH_AUDIO_PIN_3 = 17,
+	FLASH_AUDIO_PIN_4 = 18,
+	FLASH_AUDIO_PIN_5 = 19,
+	FLASH_AUDIO_PIN_6 = 20,
+	FLASH_AUDIO_PIN_7 = 21,
+	FLASH_AUDIO_PIN_8 = 22,
+	FLASH_AUDIO_PIN_9 = 23,
+	FLASH_AUDIO_PIN_10 = 24,
+	FLASH_AUDIO_PIN_11 = 25,
+	FLASH_AUDIO_PIN_12 = 26,
+	FLASH_AUDIO_PIN_13 = 27,
+	FLASH_AUDIO_PIN_14 = 28,
+	FLASH_AUDIO_PIN_15 = 29,
+	FLASH_AUDIO_PIN_16 = 30,
+	ASSOCIATED_PCM_IN = 31,
+	EXTERNAL_PCM_IN = 32,
+	SYSTEM_PCM_IN = 33,
+	APP_PCM_IN = 34,
+	DOWNMIX_PCM_OUT = 35,
+	RAW_PCM_OUT = 36,
+	EXT_PCM_OUT = 37,
+	EXT_INBAND_QUEUE = 38,
+	NON_PCM_IN = 39,
+	DTS_LA_IN0 = 40,
+	DTS_LA_IN1 = 41,
+	DTS_LA_IN2 = 42,
+	DTS_LA_IN3 = 43,
+	DTS_LA_IN4 = 44,
+	DTS_LA_IN5 = 45,
+	DTS_LA_IN6 = 46,
+	DTS_LA_IN7 = 47,
+	TDM_IN = 48,
+	PCM_PACKED_IN = 49,
+	APP_PCM_OUT = 50,
+	APP_LPCM_OUT = 51,
+	DWNSTRM_INBAND_QUEUE = 200,
+	EXT_DWNSTRM_INBAND_QUEUE = 201,
+	RAWOUT_INFOOUT_QUEUE = 202,
+	RAWOUT_INFOIN_QUEUE = 203,
+};
+
+enum AUDIO_ENUM_PRIVAETINFO {
+	ENUM_PRIVATEINFO_AUDIO_FORMAT_PARSER_CAPABILITY = 0,
+	ENUM_PRIVATEINFO_AUDIO_DECODER_CAPABILITY = 1,
+	ENUM_PRIVATEINFO_AUDIO_CONFIG_CMD_BS_INFO = 2,
+	ENUM_PRIVATEINFO_AUDIO_CHECK_LPCM_ENDIANESS = 3,
+	ENUM_PRIVATEINFO_AUDIO_CONFIG_CMD_AO_DELAY_INFO = 4,
+	ENUM_PRIVATEINFO_AUDIO_AO_CHANNEL_VOLUME_LEVEL = 5,
+	ENUM_PRIVATEINFO_AUDIO_GET_FLASH_PIN = 6,
+	ENUM_PRIVATEINFO_AUDIO_RELEASE_FLASH_PIN = 7,
+	ENUM_PRIVATEINFO_AUDIO_GET_MUTE_N_VOLUME = 8,
+	ENUM_PRIVATEINFO_AUDIO_AO_MONITOR_FULLNESS = 9,
+	ENUM_PRIVATEINFO_AUDIO_CONTROL_FLASH_VOLUME = 10,
+	ENUM_PRIVATEINFO_AUDIO_CONTROL_DAC_SWITCH = 11,
+	ENUM_PRIVATEINFO_AUDIO_PREPROCESS_CONFIG = 12,
+	ENUM_PRIVATEINFO_AUDIO_CHECK_SECURITY_ID = 13,
+	ENUM_PRIVATEINFO_AUDIO_LOW_DELAY_PARAMETERS = 14,
+	ENUM_PRIVATEINFO_AUDIO_SET_NETWORK_JITTER = 15,
+	ENUM_PRIVATEINFO_AUDIO_GET_QUEUE_DATA_SIZE = 16,
+	ENUM_PRIVATEINFO_AUDIO_GET_SHARE_MEMORY_FROM_ALSA = 17,
+	ENUM_PRIVATEINFO_AUDIO_AI_CONNECT_ALSA = 18,
+	ENUM_PRIVATEINFO_AUDIO_SET_PCM_FORMAT = 19,
+	ENUM_PRIVATEINFO_AUDIO_DO_SELF_DESTROY_FLOW = 20,
+	ENUM_PRIVATEINFO_AUDIO_GET_SAMPLING_RATE = 21,
+	ENUM_PRIVATEINFO_AUDIO_SLAVE_TIMEOUT_THRESHOLD = 22,
+	ENUM_PRIVATEINFO_AUDIO_GET_GLOBAL_AO_INSTANCEID = 23,
+	ENUM_PRIVATEINFO_AUDIO_SET_CEC_PARAMETERS = 24,
+	ENUM_PRIVATEINFO_AUDIO_INIT_DBG_DUMP_MEM = 25,
+	ENUM_PRIVATEINFO_AUDIO_AI_GET_AO_FLASH_PIN = 26,
+	ENUM_PRIVATEINFO_AUDIO_AI_SET_AO_FLASH_PIN = 27,
+	ENUM_PRIVATEINFO_AUDIO_GET_PP_FREE_PINID = 28,
+	ENUM_PRIVATEINFO_AUDIO_HDMI_RX_CONNECT_TO_BT = 29,
+	ENUM_PRIVATEINFO_AUDIO_GET_BS_ERR_RATE = 30,
+	ENUM_PRIVATEINFO_AUDIO_SET_RESUME_IR_KEYS = 31,
+	ENUM_PRIVATEINFO_SET_GSTREAMER_PTS_ACC_MODE = 32,
+	ENUM_PRIVATEINFO_AUDIO_GET_BONDING_TYPE = 33,
+	ENUM_PRIVATEINFO_AUDIO_SHARE_MEMORY_FOR_PORTING_FIRMWARE = 34,
+	ENUM_PRIVATEINFO_AUDIO_SET_DVDPLAYER_AO_VERSION = 35,
+	ENUM_PRIVATEINFO_AUDIO_MS_PP_CERT = 36,
+	ENUM_PRIVATEINFO_AUDIO_TRIGGER_EVENT = 37,
+	ENUM_PRIVATEINFO_AUDIO_AI_NON_PCM_IN = 38,
+	ENUM_PRIVATEINFO_OMX_AUDIO_VERSION = 39,
+	ENUM_PRIVATEINFO_AUDIO_AI_PAD_IN = 40,
+	ENUM_PRIVATEINFO_AUDIO_MS_MAJOR_DECODER_PIN = 41,
+	ENUM_PRIVATEINFO_AUDIO_PROVIDE_RAWOUT_LATENCY = 42,
+	ENUM_PRIVATEINFO_AUDIO_MS_MIXER_IGNORE_PIN = 43,
+	ENUM_PRIVATEINFO_AUDIO_MS_CERTIFICATION_PLATFORM = 44,
+	ENUM_PRIVATEINFO_AUDIO_MS_MIXER_PIN_NEW_SEG = 45,
+	ENUM_PRIVATEINFO_AUDIO_MS_DEC_DROP_BY_PTS = 46,
+	ENUM_PRIVATEINFO_AUDIO_MS_DEC_INIT_PTS_OFFSET = 47,
+	ENUM_PRIVATEINFO_AUDIO_MS_PP_OUTPUT_TYPE = 48,
+	ENUM_PRIVATEINFO_AUDIO_DTS_ENCODER_CONFIG = 49,
+	ENUM_PRIVATEINFO_AUDIO_GET_FW_VERSION = 50,
+	ENUM_PRIVATEINFO_AUDIO_DTS_M8_IN_CONFIG = 51,
+	ENUM_PRIVATEINFO_AUDIO_DTS_M8_LA_NUM = 52,
+	ENUM_PRIVATEINFO_AUDIO_DTS_M8_SET_OUTPUT_FORMAT = 53,
+	ENUM_PRIVATEINFO_AUDIO_SET_DRC_CFG = 54,
+	ENUM_PRIVATEINFO_AUDIO_DTS_M8_LA_ERROR_MSG = 55,
+	ENUM_PRIVATEINFO_GET_B_VALUE = 56,
+	ENUM_PRIVATEINFO_AUDIO_ENTER_SUSPEND = 57,
+	ENUM_PRIVATEINFO_AUDIO_MPEGH_IN_CONFIG = 58,
+	ENUM_PRIVATEINFO_AUDIO_SET_LOW_WATERLEVEL = 59,
+};
+
+enum AUDIO_ENUM_AIO_PRIVAETINFO {
+	ENUM_PRIVATEINFO_AIO_AO_INTERFACE_SWITCH_CONTROL = 0,
+	ENUM_PRIVATEINFO_AIO_AI_INTERFACE_SWITCH_CONTROL = 1,
+	ENUM_PRIVATEINFO_AIO_ALSA_DESTROY_AI_FLOW = 2,
+	ENUM_PRIVATEINFO_AIO_AI_NONPCM_WRITE_BACK_BS = 3,
+	ENUM_PRIVATEINFO_AIO_HDMIRX_LATENCY_MEM = 4,
+	ENUM_PRIVATEINFO_AIO_AI_LOOPBACK_AO = 5,
+	ENUM_PRIVATEINFO_AIO_AI_LOOPBACK_HDMITX = 6,
+	ENUM_PRIVATEINFO_AIO_AI_LOOPBACK_DAC = 7,
+	ENUM_PRIVATEINFO_AIO_AI_ADC_ANALOG = 8,
+	ENUM_PRIVATEINFO_AIO_AI_MULTIPLE_ADC = 9,
+	ENUM_PRIVATEINFO_AIO_AI_ADC_AMIC = 9 + 1,
+	ENUM_PRIVATEINFO_AIO_KERNEL_RPC = 9 + 2,
+	ENUM_PRIVATEINFO_AIO_SET_SE_CLK = 9 + 3,
+	ENUM_PRIVATEINFO_AIO_AI_PRIVATEINFO = 9 + 4,
+	ENUM_PRIVATEINFO_AIO_DELIVER_SCPU_FW_PID = 9 + 5,
+	ENUM_PRIVATEINFO_AIO_GET_D_VISION_CAPABILITY = 9 + 6,
+	ENUM_PRIVATEINFO_AIO_GET_AUDIO_PROCESSING_AI = 9 + 7,
+	ENUM_PRIVATEINFO_AIO_AI_GET_HW_VALID = 9 + 8,
+	ENUM_PRIVATEINFO_AIO_IS_EARC_C = 9 + 9,
+	ENUM_PRIVATEINFO_AIO_AO_FLASH_LPCM = 9 + 10,
+	ENUM_PRIVATEINFO_AIO_TRSENC_INFO = 9 + 11,
+	ENUM_PRIVATEINFO_AIO_AI_PAUSE_HW = 9 + 12,
+	ENUM_PRIVATEINFO_AIO_PCMR_OUT_FORMAT = 9 + 13,
+	ENUM_PRIVATEINFO_AIO_SYS_APP_SND_EXIST = 9 + 14,
+	ENUM_PRIVATEINFO_AIO_ENC_EOS_INFO = 9 + 15,
+	ENUM_PRIVATEINFO_AIO_MSV2_3_PARAM_DOWNMIXED_MODE = 9 + 16,
+	ENUM_PRIVATEINFO_AIO_MSV2_3_PARAM_DRC_MODE = 9 + 17,
+	ENUM_PRIVATEINFO_AIO_MSV2_3_PARAM_MC_DRC_CUT = 9 + 18,
+	ENUM_PRIVATEINFO_AIO_MSV2_3_PARAM_MC_DRC_BOOST = 9 + 19,
+	ENUM_PRIVATEINFO_AIO_MSV2_3_PARAM_DMX_DRC_CUT = 9 + 20,
+	ENUM_PRIVATEINFO_AIO_MSV2_3_PARAM_DMX_DRC_BOOST = 9 + 21,
+	ENUM_PRIVATEINFO_AIO_MSV2_6_NEW_FLOW_OUTPUT_TYPE = 9 + 22,
+	ENUM_PRIVATEINFO_AIO_MSV2_6_NEW_FLOW_LISTENING_DAP_TUNING_INFO = 9 + 23,
+	ENUM_PRIVATEINFO_AIO_MSV2_6_NEW_FLOW_LISTENING_DAP_TUNING_MAPPING = 9 + 24,
+	ENUM_PRIVATEINFO_AIO_MSV2_6_NEW_FLOW_LISTENING_IS_PCMR_SECONDARY_OUT = 9 + 25,
+	ENUM_PRIVATEINFO_AIO_MSV2_6_NEW_FLOW_LISTENING_DAP_SPEAKER_LAST_2CH_OUT = 9 + 26,
+	ENUM_PRIVATEINFO_AIO_MSV2_3_PARAM_LOUDNESS_EQUIVALENCE_MODE = 9 + 27,
+	ENUM_PRIVATEINFO_AIO_MSV2_6_NEW_FLOW_SECONDARY_OUT_CH_NUM = 9 + 28,
+	ENUM_PRIVATEINFO_AIO_MSV2_6_HDMI_OUTPUT_TYPE = 9 + 29,
+	ENUM_PRIVATEINFO_AIO_AO_PCM_PIN_LPCM = 9 + 30,
+	ENUM_PRIVATEINFO_AIO_TOTAL_NUM = 9 + 31,
+};
+
+enum AUDIO_ENDIANTYPE {
+	AUDIO_BIG_ENDIAN        = 0,       // CD,DVD type
+	AUDIO_LITTLE_ENDIAN     = 1,
+	AUDIO_LPCM_DHMV_TYPE    = 2,       // HDMV type
+};
+
+enum ENUM_AUDIO_CHANNEL_OUT_INDEX {
+	ENUM_AUDIO_NULL_CHANNEL_INDEX = 0,
+
+	ENUM_AUDIO_LEFT_FRONT_INDEX = 1,            // L
+	ENUM_AUDIO_RIGHT_FRONT_INDEX = 2,           // R
+	ENUM_AUDIO_CENTER_FRONT_INDEX = 5,          // C
+	ENUM_AUDIO_LFE_INDEX = 6,                   // LFE
+	ENUM_AUDIO_LEFT_SURROUND_REAR_INDEX = 3,    // Ls or Lsr
+	ENUM_AUDIO_RIGHT_SURROUND_REAR_INDEX = 4,   // Rs or Rsr
+	ENUM_AUDIO_LEFT_OUTSIDE_FRONT_INDEX = 7,    // ENUM_AUDIO_LEFT_SURROUND_SIDE_INDEX,  Lss
+	ENUM_AUDIO_RIGHT_OUTSIDE_FRONT_INDEX = 8,   // ENUM_AUDIO_RIGHT_SURROUND_SIDE_INDEX, Rss
+	ENUM_AUDIO_SPDIF_LEFT_CHANNEL_INDEX = 9,
+	ENUM_AUDIO_SPDIF_RIGHT_CHANNEL_INDEX = 10,
+
+	ENUM_AUDIO_SURROUND_INDEX = 11,
+	ENUM_AUDIO_CENTER_SURROUND_REAR_INDEX = 12,
+	ENUM_AUDIO_OverHead_INDEX = 13,
+
+	ENUM_AUDIO_LEFT_SURROUND_INDEX = 14,
+	ENUM_AUDIO_RIGHT_SURROUND_INDEX = 15,
+	ENUM_AUDIO_LEFT_FRONT_HIGH_INDEX = 16,
+	ENUM_AUDIO_RIGHT_FRONT_HIGH_INDEX = 17,
+	ENUM_AUDIO_LEFT_INNER_FRONT_INDEX = 18,
+	ENUM_AUDIO_RIGHT_INNER_FRONT_INDEX = 19,
+	ENUM_AUDIO_LEFT_REAR_INDEX = 20,
+	ENUM_AUDIO_RIGHT_REAR_INDEX = 21,
+	ENUM_AUDIO_LEFT_SURROUND_DIRECT_INDEX = 22,
+	ENUM_AUDIO_RIGHT_SURROUND_DIRECT_INDEX = 23,
+	ENUM_AUDIO_CENTER_FRONT_HIGH_INDEX = 24,
+	ENUM_AUDIO_LFE2_INDEX = 25,
+
+	ENUM_AUDIO_SPDIF_NON_PCM_TYPE = 256,
+	ENUM_AUDIO_ENABLE_DOWNMIX = 257
+};
+
+enum {
+	ENUM_DT_AO_DAC    = 0,
+	ENUM_DT_AO_I2S    = 1,
+	ENUM_DT_AO_SPDIF  = 2,
+	ENUM_DT_AO_HDMI   = 3,
+	ENUM_DT_AO_GLOBAL = 4,
+	ENUM_DT_AO_TDM    = 5,
+	ENUM_DT_AO_TDM1   = 6,
+	ENUM_DT_AO_TDM2   = 7,
+	ENUM_DT_AO_I2S1   = 8,
+	ENUM_DT_AO_I2S2   = 9,
+	ENUM_DT_AO_BTPCM  = 10,
+	ENUM_DT_AO_BTPCM_TEST  = 11,
+};
+
+enum AUDIO_ENUM_AI_LOOPBACK_DEV {
+	ENUM_RPC_AI_LOOPBACK_HDMITX = 0,
+	ENUM_RPC_AI_LOOPBACK_DAC = 0 + 1,
+	ENUM_RPC_AI_LOOPBACK_FROM_AO_I2S = 0 + 2,
+	ENUM_RPC_AI_LOOPBACK_FROM_AO_SPDIF = 0 + 3,
+	ENUM_RPC_AI_LOOPBACK_FROM_AO_HDMI = 0 + 4,
+	ENUM_RPC_AI_LOOPBACK_TOTAL_NUM = 0 + 5,
+};
+
+enum AUDIO_FORMAT_OF_AI_SEND_TO_ALSA {
+	AUDIO_ALSA_FORMAT_32BITS_BE_PCM = 0,
+	AUDIO_ALSA_FORMAT_16BITS_LE_LPCM = 1,
+	AUDIO_ALSA_FORMAT_24BITS_LE_LPCM = 2,
+	AUDIO_ALSA_FORMAT_NONE = 3,
+	AUDIO_ALSA_FORMAT_32BITS_LE_LPCM = 3 + 1,
+	AUDIO_ALSA_FORMAT_TOTAL_NUM = 3 + 2,
+};
+
+struct alsa_latency_info {
+	unsigned int latency;
+	unsigned int ptsl;
+	unsigned int ptsh;
+	unsigned int sum; /* latency + ptsL */
+	unsigned int decin_wp;
+	unsigned int sync;
+	unsigned int dec_in_delay;
+	unsigned int dec_out_delay;
+	unsigned int ao_delay;
+	int rvd[8];
+};
+
+struct ringbuf_header_ptrs {
+	unsigned int *p_magic;
+	unsigned int *p_begin_addr;
+	unsigned int *p_size;
+	unsigned int *p_buffer_id;
+	unsigned int *p_write_ptr;
+	unsigned int *p_num_read_ptr;
+	unsigned int *p_read_ptr;
+	int *p_file_offset;
+	int *p_requested_file_offset;
+	int *p_file_size;
+	int *p_seekable;
+	struct alsa_latency_info *p_latency;
+};
+
+struct rpc_data {
+	struct rpc_struct info;
+	unsigned int command;
+	unsigned int param1;
+	unsigned int param2;
+};
+
+struct rpc_result {
+	unsigned int result;
+	int data;
+};
+
+struct rpc_aio_ctrl {
+	unsigned int bitmap;
+	unsigned int i2s_ch;
+	unsigned int i2s_mode;
+};
+
+struct rpc_privateinfo_result {
+	int instance_id;
+	volatile int private_info[16];
+};
+
+struct rpc_ringbuffer_header {
+	int instance_id;
+	int pin_id;
+	int ringbuffer_header_list[8];
+	int read_idx;
+	int list_size;
+};
+
+struct rpc_create_ao_agent {
+	int instance_id;
+	int type;
+};
+
+struct rpc_privateinfo_param {
+	int instance_id;
+	unsigned int type;
+	volatile int private_info[16];
+};
+
+struct rtk_rpc_priv {
+	struct rtk_krpc_ept_info *ept;
+
+	void *vaddr;
+	dma_addr_t paddr;
+
+	struct rpc_data data;
+};
+
+int rpc_create_audio_agent(struct rtk_rpc_priv *priv, int pin, int *ao_id);
+int rpc_init_ringbuffer_header(struct rtk_rpc_priv *priv,
+			      struct rpc_ringbuffer_header *rpc);
+int rpc_put_shmem_latency(struct rtk_rpc_priv *priv, int ao_id, int pin, void *p);
+int init_ringbuf_header_ptrs(struct ringbuf_header_ptrs *ptrs,
+			     void *base, bool cacheable);
+int rpc_pause_svc(struct rtk_rpc_priv *priv, int id);
+int rpc_run_svc(struct rtk_rpc_priv *priv, int id);
+int rpc_stop_svc(struct rtk_rpc_priv *priv, int id);
+int rpc_get_ao_flash_pin(struct rtk_rpc_priv *priv, int ao_id, int *pin);
+int rpc_put_ao_flash_pin(struct rtk_rpc_priv *priv, int ao_id, int *pin);
+int rpc_get_chache_config(struct rtk_rpc_priv *priv, int *cacheable);
+int rpc_config_ao(struct rtk_rpc_priv *priv, int ao_id, int pin,
+		  struct snd_pcm_runtime *runtime);
+int rpc_ctrl_aio(struct rtk_rpc_priv *priv, int ao_id, struct rpc_aio_ctrl *ctrl);
+int rpc_ept_init(struct rtk_rpc_priv *priv);
+int rpc_config_i2s_in(struct rtk_rpc_priv *priv, int ai_id);
+int rpc_config_loopback_in(struct rtk_rpc_priv *priv, int ai_id);
+int rpc_ai_connect_alsa(struct rtk_rpc_priv *priv,
+			struct snd_pcm_runtime *runtime, int ai_id);
+int rpc_destroy_ai_flow(struct rtk_rpc_priv *priv, int ai_id, int configured);
+
+#endif /* SND_HIFI_RPC_H */
diff --git a/sound/soc/realtek/rtk-hifi-rt5650-mc.c b/sound/soc/realtek/rtk-hifi-rt5650-mc.c
new file mode 100644
index 000000000000..deb3cd8ac698
--- /dev/null
+++ b/sound/soc/realtek/rtk-hifi-rt5650-mc.c
@@ -0,0 +1,599 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// rtk-hifi.c  --
+//	Realtek ALSA SoC machine driver
+//
+// Copyright (c) 2024 Realtek Inc.
+// Author: Simon Hsu <simon_hsu@realtek.com>
+//
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <sound/soc.h>
+
+#include <sound/jack.h>
+#include "../codecs/rt5645.h"
+
+#define RT5650_CODEC_DAI1	"rt5645-aif1"
+#define RT5650_CODEC_DAI2	"rt5645-aif2"
+
+#define DP_CODEC_DAI	"spdif-hifi"
+#define HDMI_CODEC_DAI	"spdif-hifi"
+
+enum {
+	DAI_LINK_SOF_RDL2_BE = 0,
+	DAI_LINK_SOF_RUL4_BE,
+	DAI_LINK_AO0_BE,
+	DAI_LINK_DL1_FE,
+	DAI_LINK_DL2_FE,
+	DAI_LINK_UL1_FE,
+	DAI_LINK_UL2_FE,
+	DAI_LINK_I2S,
+	DAI_LINK_I2S_LOOPBACK,
+	DAI_LINK_I2S_RT5650,
+	DAI_LINK_DMIC_BE,
+	DAI_LINK_DP_AUDIO_BE,
+	DAI_LINK_HDMI_AUDIO_BE,
+};
+
+struct rtk_soc_card_data {
+	void *mach_priv;
+	void *sof_priv;
+};
+
+/* FE */
+SND_SOC_DAILINK_DEFS(DL1_FE,
+		     DAILINK_COMP_ARRAY(COMP_CPU("DL1")),
+		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
+		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
+
+SND_SOC_DAILINK_DEFS(DL2_FE,
+		     DAILINK_COMP_ARRAY(COMP_CPU("DL2")),
+		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
+		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
+
+SND_SOC_DAILINK_DEFS(UL1_FE,
+		     DAILINK_COMP_ARRAY(COMP_CPU("UL1")),
+		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
+		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
+
+SND_SOC_DAILINK_DEFS(UL2_FE,
+		     DAILINK_COMP_ARRAY(COMP_CPU("UL2")),
+		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
+		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
+
+SND_SOC_DAILINK_DEFS(RDAI_I2S1, DAILINK_COMP_ARRAY(COMP_CPU("SOF_DL2")),
+		     DAILINK_COMP_ARRAY(COMP_CODEC(NULL,
+						RT5650_CODEC_DAI2)),
+		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
+
+SND_SOC_DAILINK_DEFS(RDAI_I2S0, DAILINK_COMP_ARRAY(COMP_CPU("SOF_UL4")),
+		     DAILINK_COMP_ARRAY(COMP_CODEC(NULL,
+						RT5650_CODEC_DAI1)),
+		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
+
+SND_SOC_DAILINK_DEFS(HDMI_AO, DAILINK_COMP_ARRAY(COMP_CPU("SOF_HDMI")),
+		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
+                     DAILINK_COMP_ARRAY(COMP_EMPTY()));
+
+SND_SOC_DAILINK_DEFS(DP_AO, DAILINK_COMP_ARRAY(COMP_CPU("SOF_DP")),
+                     DAILINK_COMP_ARRAY(COMP_DUMMY()),
+		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
+/* BE */
+SND_SOC_DAILINK_DEFS(I2S0,
+		     DAILINK_COMP_ARRAY(COMP_CPU("I2S0")),
+		     DAILINK_COMP_ARRAY(COMP_CODEC(NULL,
+						RT5650_CODEC_DAI1)),
+		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
+
+SND_SOC_DAILINK_DEFS(I2S0_LOOPBACK,
+		     DAILINK_COMP_ARRAY(COMP_CPU("I2S0_LOOPBACK")),
+		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
+		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
+
+SND_SOC_DAILINK_DEFS(i2s0_rt5650,
+		     DAILINK_COMP_ARRAY(COMP_CPU("I2S0")),
+		     DAILINK_COMP_ARRAY(COMP_CODEC(NULL,
+						RT5650_CODEC_DAI1)),
+		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
+
+SND_SOC_DAILINK_DEFS(DMIC_PDM,
+		     DAILINK_COMP_ARRAY(COMP_CPU("SOF_DMIC")),
+		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
+		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
+
+SND_SOC_DAILINK_DEFS(AUDIO_OUT0,
+		     DAILINK_COMP_ARRAY(COMP_CPU("AUDIO_OUT0")),
+		     DAILINK_COMP_ARRAY(COMP_CODEC(NULL,
+						RT5650_CODEC_DAI1)),
+		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
+
+static int rtk_sof_be_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	return 0;
+}
+
+static int rtk_rt5650_i2s_hw_params(struct snd_pcm_substream *substream,
+				    struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
+//	struct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);
+	struct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);
+	int ret = 0;
+	int mclk;
+
+	switch (params_rate(params)) {
+	case 8000:
+	case 16000:
+	case 24000:
+	case 32000:
+	case 48000:
+	case 64000:
+	case 96000:
+		mclk = 24576000;
+		break;
+	case 11025:
+	case 22050:
+	case 44100:
+	case 88200:
+		mclk = 22579200;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	ret = snd_soc_dai_set_sysclk(codec_dai, 0, mclk,
+				     SND_SOC_CLOCK_IN);
+	if (ret < 0) {
+		dev_err(codec_dai->dev, "Can't set codec clock %d\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+static struct snd_soc_jack rtk_rt5650_jack;
+
+static int rtk_rt5650_init(struct snd_soc_pcm_runtime *runtime)
+{
+	struct snd_soc_card *card = runtime->card;
+	struct snd_soc_component *component = asoc_rtd_to_codec(runtime, 0)->component;
+	int ret;
+	int type =	SND_JACK_HEADPHONE | SND_JACK_MICROPHONE |
+				SND_JACK_BTN_0 | SND_JACK_BTN_1 |
+				SND_JACK_BTN_2 | SND_JACK_BTN_3;
+
+	rt5645_sel_asrc_clk_src(component,
+				RT5645_DA_STEREO_FILTER |
+				RT5645_AD_STEREO_FILTER,
+				RT5645_CLK_SEL_I2S1_ASRC);
+
+	/* enable jack detection */
+	ret = snd_soc_card_jack_new(card, "Headphone Jack",
+				    type,
+				    &rtk_rt5650_jack);
+
+	if (ret) {
+		dev_err(card->dev, "Can't new Headphone Jack %d\n", ret);
+		return ret;
+	}
+
+	ret = snd_soc_component_set_jack(component, &rtk_rt5650_jack, &type);
+	if (ret) {
+		dev_err(card->dev,"comp set jack FAIL\n");
+	}
+
+	return ret;
+
+}
+
+static struct snd_soc_jack rtk_hdmi_jack;
+static int rtk_hdmi_codec_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_jack *jack = &rtk_hdmi_jack;
+	struct snd_soc_component *cmpnt_codec =	asoc_rtd_to_codec(rtd,0)->component;
+	int ret = 0;
+
+	ret = snd_soc_card_jack_new(rtd->card, "HDMI Jack", SND_JACK_LINEOUT, jack);
+
+	if(ret) {
+		pr_err("HDMI Jack Fail!");
+		return ret;
+	}
+
+	ret = snd_soc_component_set_jack(cmpnt_codec, jack, NULL);
+
+	if(ret) {
+		pr_err("component set HDMI Jack Fail!");
+		return ret;
+	}
+
+	return 0;
+}
+
+static struct snd_soc_jack rtk_dp_jack;
+static int rtk_dp_codec_init(struct snd_soc_pcm_runtime *rtd)
+{
+        struct snd_soc_jack *jack = &rtk_dp_jack;
+        struct snd_soc_component *cmpnt_codec = asoc_rtd_to_codec(rtd,0)->component;
+        int ret = 0;
+
+        ret = snd_soc_card_jack_new(rtd->card, "DP Jack", SND_JACK_LINEOUT, jack);
+
+        if(ret) {
+                pr_err("DP Jack Fail!");
+                return ret;
+        }
+
+        ret = snd_soc_component_set_jack(cmpnt_codec, jack, NULL);
+
+        if(ret) {
+                pr_err("component set DP Jack Fail!");
+                return ret;
+        }
+
+        return 0;
+}
+
+static const struct snd_soc_ops rtk_sof_be_ops = {
+	.hw_params = rtk_sof_be_hw_params,
+};
+
+static const struct snd_soc_ops rtk_rt5650_i2s_ops = {
+	.hw_params = rtk_rt5650_i2s_hw_params,
+};
+
+static struct snd_soc_dai_link rtk_hifi_dai_links[] = {
+	[DAI_LINK_SOF_RDL2_BE] = {
+		.name = "RDAI_I2S1",
+		.no_pcm = 1,
+		.dpcm_playback = 1,
+		//.dpcm_capture = 1,
+		.ops = &rtk_rt5650_i2s_ops,
+		.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+			SND_SOC_DAIFMT_CBS_CFS,
+		SND_SOC_DAILINK_REG(RDAI_I2S1),
+	},
+	[DAI_LINK_SOF_RUL4_BE] = {
+		.name = "RDAI_I2S",
+		.no_pcm = 1,
+		.dpcm_playback = 1,
+		.dpcm_capture = 1,
+		.init = rtk_rt5650_init,
+		.ops = &rtk_rt5650_i2s_ops,
+		.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+			SND_SOC_DAIFMT_CBS_CFS,
+		SND_SOC_DAILINK_REG(RDAI_I2S0),
+	},
+	[DAI_LINK_DMIC_BE] = {
+		.name = "RDAI_DMIC",
+		.no_pcm = 1,
+		.dpcm_capture = 1,
+		SND_SOC_DAILINK_REG(DMIC_PDM),
+	},
+	[DAI_LINK_HDMI_AUDIO_BE] = {
+		.name = "RDAI_HDMI",
+		.no_pcm = 1,
+		.dpcm_playback = 1,
+		SND_SOC_DAILINK_REG(HDMI_AO),
+	},
+	[DAI_LINK_DP_AUDIO_BE] = {
+		.name = "RDAI_DP",
+		.no_pcm = 1,
+		.dpcm_playback = 1,
+		SND_SOC_DAILINK_REG(DP_AO),
+	},
+	[DAI_LINK_AO0_BE] = {
+		.name = "RDAI_SOC_AO0",
+		.no_pcm = 1,
+		.dpcm_playback = 1,
+		.init = rtk_rt5650_init,
+		.ops = &rtk_rt5650_i2s_ops,
+		.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+			SND_SOC_DAIFMT_CBS_CFS,
+		SND_SOC_DAILINK_REG(AUDIO_OUT0),
+	},
+	[DAI_LINK_I2S] = {
+		.name = "RDAI_SOC_I2S",
+		.no_pcm = 1,
+		.dpcm_capture = 1,
+		.ops = &rtk_rt5650_i2s_ops,
+		.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+			SND_SOC_DAIFMT_CBS_CFS,
+		SND_SOC_DAILINK_REG(I2S0),
+	},
+	[DAI_LINK_I2S_LOOPBACK] = {
+		.name = "RDAI_SOC_I2S0_LOOPBACK",
+		.no_pcm = 1,
+		.dpcm_capture = 1,
+		SND_SOC_DAILINK_REG(I2S0_LOOPBACK),
+	},
+	[DAI_LINK_DL1_FE] = {
+		.name = "RDAI_DL1_FE",
+		.stream_name = "DL1 Playback - AO0",
+		.trigger = {
+			SND_SOC_DPCM_TRIGGER_POST,
+			SND_SOC_DPCM_TRIGGER_POST,
+		},
+		.dynamic = 1,
+		.dpcm_playback = 1,
+		SND_SOC_DAILINK_REG(DL1_FE),
+	},
+	[DAI_LINK_DL2_FE] = {
+		.name = "RDAI_DL2_FE",
+		.stream_name = "DL2 Playback",
+		.trigger = {
+			SND_SOC_DPCM_TRIGGER_POST,
+			SND_SOC_DPCM_TRIGGER_POST,
+		},
+		.dynamic = 1,
+		.dpcm_playback = 1,
+		SND_SOC_DAILINK_REG(DL2_FE),
+	},
+	[DAI_LINK_UL1_FE] = {
+		.name = "RDAI_UL1_FE",
+		.stream_name = "I2S0 Capture",
+		.trigger = {
+			SND_SOC_DPCM_TRIGGER_POST,
+			SND_SOC_DPCM_TRIGGER_POST,
+		},
+		.dynamic = 1,
+		.dpcm_capture = 1,
+		SND_SOC_DAILINK_REG(UL1_FE),
+	},
+	[DAI_LINK_UL2_FE] = {
+		.name = "RDAI_UL2_FE",
+		.stream_name = "I2S0 Loopback Capture",
+		.trigger = {
+			SND_SOC_DPCM_TRIGGER_POST,
+			SND_SOC_DPCM_TRIGGER_POST,
+		},
+		.dynamic = 1,
+		.dpcm_capture = 1,
+		SND_SOC_DAILINK_REG(UL2_FE),
+	},
+	[DAI_LINK_I2S_RT5650] = {
+		.name = "RDAI_I2S_RT5650",
+		.no_pcm = 1,
+		.dpcm_playback = 1,
+		.dpcm_capture = 1,
+		.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+			SND_SOC_DAIFMT_CBS_CFS,
+		SND_SOC_DAILINK_REG(i2s0_rt5650),
+	},
+};
+
+
+static const struct snd_soc_dapm_widget rtk_hifi_widgets[] = {
+	SND_SOC_DAPM_SPK("Left Spk", NULL),
+	SND_SOC_DAPM_SPK("Right Spk", NULL),
+	SND_SOC_DAPM_HP("Headphone Jack", NULL),
+};
+
+static const struct snd_soc_dapm_route rtk_hifi_routes[] = {
+	/* speaker */
+	{ "Left Spk", NULL, "SPOL" },
+	{ "Right Spk", NULL, "SPOR" },
+	/* headset */
+	{ "Headphone Jack", NULL, "HPOL" },
+	{ "Headphone Jack", NULL, "HPOR" },
+
+	{ "Headphone Jack", NULL, "I2S0" },
+};
+
+static const struct snd_kcontrol_new rtk_hifi_controls[] = {
+	SOC_DAPM_PIN_SWITCH("Left Spk"),
+	SOC_DAPM_PIN_SWITCH("Right Spk"),
+	SOC_DAPM_PIN_SWITCH("Headphone Jack"),
+};
+
+static struct snd_soc_card rtk_hifi_soc_card = {
+	.owner = THIS_MODULE,
+	.dai_link = rtk_hifi_dai_links,
+	.num_links = ARRAY_SIZE(rtk_hifi_dai_links),
+	.controls = rtk_hifi_controls,
+	.num_controls = ARRAY_SIZE(rtk_hifi_controls),
+	.dapm_widgets = rtk_hifi_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(rtk_hifi_widgets),
+	.dapm_routes = rtk_hifi_routes,
+	.num_dapm_routes = ARRAY_SIZE(rtk_hifi_routes),
+};
+
+int rtk_soc_dailink_parse_of(struct snd_soc_card *card, struct device_node *np,
+			     const char *propname,
+			     struct snd_soc_dai_link *pre_dai_links,
+			     int pre_num_links)
+{
+	struct device *dev = card->dev;
+	struct snd_soc_dai_link *parsed_dai_link;
+	const char *dai_name = NULL;
+	int i, j, ret, num_links, parsed_num_links = 0;
+
+	num_links = of_property_count_strings(np, "realtek,dai-link");
+	if (num_links < 0 || num_links > card->num_links) {
+		dev_err(dev, "number of dai-link is invalid %d\n", num_links);
+		return -EINVAL;
+	}
+
+	parsed_dai_link = devm_kcalloc(dev, num_links, sizeof(*parsed_dai_link),
+				       GFP_KERNEL);
+	if (!parsed_dai_link)
+		return -ENOMEM;
+
+	for (i = 0; i < num_links; i++) {
+		ret = of_property_read_string_index(np, propname, i, &dai_name);
+		if (ret) {
+			dev_err(dev,
+				"ASoC: Property '%s' index %d could not be read: %d\n",
+				propname, i, ret);
+			return ret;
+		}
+		dev_dbg(dev, "ASoC: Property get dai_name:%s\n", dai_name);
+		for (j = 0; j < pre_num_links; j++) {
+			if (!strcmp(dai_name, pre_dai_links[j].name)) {
+				memcpy(&parsed_dai_link[parsed_num_links++],
+				       &pre_dai_links[j],
+				       sizeof(struct snd_soc_dai_link));
+				break;
+			}
+		}
+	}
+
+	if (parsed_num_links != num_links)
+		return -EINVAL;
+
+	card->dai_link = parsed_dai_link;
+	card->num_links = parsed_num_links;
+
+	return 0;
+}
+
+int rtk_soc_card_probe(struct snd_soc_card *card)
+{
+	int i;
+	struct snd_soc_dai_link *dai_link;
+
+	/* Set stream_name to help sof bind widgets */
+	for_each_card_prelinks(card, i, dai_link) {
+		if (dai_link->no_pcm && !dai_link->stream_name &&
+		    dai_link->name)
+			dai_link->stream_name = dai_link->name;
+	}
+
+	return 0;
+}
+
+static int rtk_hifi_dev_probe(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = &rtk_hifi_soc_card;
+	struct snd_soc_dai_link *dai_link;
+	struct device *dev = &pdev->dev;
+	struct device_node *platform_node, *codec_node;
+	struct rtk_soc_card_data *soc_card_data;
+	int i, ret = 0;
+
+	dev_dbg(dev, "Realtek ASOC machine detected 0x%x\n",SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+			SND_SOC_DAIFMT_CBS_CFS);
+
+	card->dev = dev;
+
+	ret = snd_soc_of_parse_card_name(card, "model");
+	if (ret) {
+		dev_err(dev, "%s card name parsing error %d\n", __func__, ret);
+		return ret;
+	}
+
+	soc_card_data = devm_kzalloc(dev, sizeof(*soc_card_data), GFP_KERNEL);
+	if (!soc_card_data)
+		return -ENOMEM;
+
+	platform_node = of_parse_phandle(dev->of_node, "realtek,audio-platform", 0);
+	if (!platform_node) {
+		dev_err(dev, "%s can't find platform node\n", __func__);
+		return -EINVAL;
+	}
+
+	if (of_property_read_bool(dev->of_node, "realtek,dai-link")) {
+		ret = rtk_soc_dailink_parse_of(card, dev->of_node,
+					       "realtek,dai-link",
+					       rtk_hifi_dai_links,
+					       ARRAY_SIZE(rtk_hifi_dai_links));
+		if (ret) {
+			dev_err(&pdev->dev, "Parse dai-link fail\n");
+			return ret;
+		}
+	}
+
+	card->probe = rtk_soc_card_probe;
+
+	/* assign the node of sof driver to platforms in dai_link */
+	for_each_card_prelinks(card, i, dai_link) {
+		dai_link->platforms->of_node = platform_node;
+		if (strcmp(dai_link->name, "RDAI_I2S_RT5650") == 0) {
+			dai_link->codecs->of_node = of_parse_phandle(dev->of_node, "realtek,audio-codec", 0);
+		} else if (strcmp(dai_link->name, "RDAI_I2S") == 0 ||
+			   strcmp(dai_link->name, "RDAI_I2S1") == 0) {
+			card->dapm_routes = NULL;
+			card->num_dapm_routes = 0;//ARRAY_SIZE(rtk_hifi_routes),
+			dai_link->codecs->of_node = of_parse_phandle(dev->of_node, "realtek,audio-codec", 0);
+		} else if (strcmp(dai_link->name,"RDAI_HDMI") == 0){
+			codec_node = of_parse_phandle(dev->of_node, "realtek,hdmi-audio", 0);
+
+			if(of_device_is_available(codec_node)) {
+				dai_link->codecs->name = NULL;
+				dai_link->codecs->dai_name = HDMI_CODEC_DAI;
+				dai_link->codecs->of_node = codec_node;
+				dai_link->init = rtk_hdmi_codec_init;
+			} else
+				pr_info("Cant find CODEC,RDAI_HDMI use DUMMY CODEC");
+		} else if (strcmp(dai_link->name, "RDAI_DP") == 0) {
+                        codec_node = of_parse_phandle(dev->of_node, "realtek,dp-audio", 0);
+
+                        if(of_device_is_available(codec_node)) {
+				dai_link->codecs->name = NULL;
+				dai_link->codecs->dai_name = DP_CODEC_DAI;
+				dai_link->codecs->of_node = codec_node;
+				dai_link->init = rtk_dp_codec_init;
+                        } else
+				pr_info("Cant find CODEC,RDAI_DP use DUMMY CODEC");
+		} else if (strcmp(dai_link->name, "RDAI_SOC_AO0") == 0 || strcmp(dai_link->name, "RDAI_SOC_I2S") == 0) {
+			card->dapm_routes = NULL;
+			card->num_dapm_routes = 0;//ARRAY_SIZE(rtk_hifi_routes),
+
+			codec_node = of_parse_phandle(dev->of_node, "realtek,audio-codec", 0);
+			if(!codec_node) {
+				pr_err("Cant find codec node for %s",dai_link->name);
+				return -EINVAL;
+			}
+			dai_link->codecs->of_node = codec_node;
+		}
+	}
+
+	snd_soc_card_set_drvdata(card, soc_card_data);
+
+	ret = devm_snd_soc_register_card(&pdev->dev, card);
+	if (ret) {
+		dev_err(dev, "Soc register card failed %d\n", ret);
+		goto put_exist_node;
+	}
+
+	return ret;
+
+put_exist_node:
+	of_node_put(platform_node);
+	if (codec_node)
+		of_node_put(codec_node);
+	return ret;
+}
+
+static const struct dev_pm_ops rtk_hifi_pm_ops = {
+	.poweroff = snd_soc_poweroff,
+	.restore = snd_soc_resume,
+};
+
+static const struct of_device_id rtk_hifi_dt_match[] = {
+	{
+		.compatible = "realtek,rtd1619b-hifi-mc",
+	},
+	{},
+};
+
+static struct platform_driver rtk_hifi_driver = {
+	.driver = {
+		.name = "rtk-hifi",
+#ifdef CONFIG_OF
+		.of_match_table = rtk_hifi_dt_match,
+#endif
+		.pm = &rtk_hifi_pm_ops,
+	},
+	.probe = rtk_hifi_dev_probe,
+};
+module_platform_driver(rtk_hifi_driver);
+
+/* Module information */
+MODULE_DESCRIPTION("REALTEK ALSA SoC machine driver");
+MODULE_AUTHOR("Simon Hsu <simon_hsu@realtek.com>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("realtek soc card");
-- 
2.44.1

