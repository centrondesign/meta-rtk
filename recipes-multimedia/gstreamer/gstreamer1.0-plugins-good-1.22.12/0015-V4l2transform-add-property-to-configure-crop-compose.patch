From e4c710565b7ccac5e67f4dedc5ca0a989db7e62c Mon Sep 17 00:00:00 2001
From: hayward_ling <hayward_ling@realtek.com>
Date: Fri, 25 Apr 2025 20:07:54 +0800
Subject: [PATCH] V4l2transform: add property to configure crop/compose
Upstream-Status: Inappropriate [rtk specific]

---
 sys/v4l2/gstv4l2object.c    |  59 +++++++++++++
 sys/v4l2/gstv4l2object.h    |   1 +
 sys/v4l2/gstv4l2transform.c | 172 +++++++++++++++++++++++++++++++++++-
 sys/v4l2/gstv4l2transform.h |  15 ++++
 4 files changed, 245 insertions(+), 2 deletions(-)

diff --git a/sys/v4l2/gstv4l2object.c b/sys/v4l2/gstv4l2object.c
index a102ec9..42875ec 100644
--- a/sys/v4l2/gstv4l2object.c
+++ b/sys/v4l2/gstv4l2object.c
@@ -4581,6 +4581,65 @@ unsupported_format:
   }
 }
 
+/**
+ * gst_v4l2_object_set_compose:
+ * @obj: the object
+ * @compose_rect: the region to compose
+ *
+ * Compose the video data to the regions specified in the @compose_rect.
+ *
+ * For capture devices, this compose the image sensor / video stream provided by
+ * the V4L2 device. The composing area specifies which part of the buffer is
+ * actually written to by the hardware.
+ * For output devices, this compose the memory buffer that GStreamer passed to
+ * the V4L2 device. The application may select the part of display where the
+ * image should be displayed. The size and position of such a window is
+ * controlled by the compose target.
+ *
+ * The compose_rect may be modified by the V4L2 device to a region that
+ * fulfills H/W requirements.
+ *
+ * Returns: %TRUE on success, %FALSE on failure.
+ */
+gboolean
+gst_v4l2_object_set_compose (GstV4l2Object * obj,
+    struct v4l2_rect *compose_rect)
+{
+  struct v4l2_selection sel = { 0 };
+
+  GST_V4L2_CHECK_OPEN (obj);
+
+  sel.type = obj->type;
+  sel.target = V4L2_SEL_TGT_COMPOSE;
+  sel.flags = 0;
+  sel.r = *compose_rect;
+
+  GST_DEBUG_OBJECT (obj->dbg_obj,
+      "Desired composing left %u, top %u, size %ux%u", sel.r.left, sel.r.top,
+      sel.r.width, sel.r.height);
+
+  if (obj->ioctl (obj->video_fd, VIDIOC_S_SELECTION, &sel) < 0) {
+    if (errno != ENOTTY) {
+      GST_WARNING_OBJECT (obj->dbg_obj,
+          "Failed to set compose rectangle with VIDIOC_S_SELECTION: %s",
+          g_strerror (errno));
+      return FALSE;
+    } else {
+      GST_DEBUG_OBJECT (obj->dbg_obj,
+          "VIDIOC_S_SELECTION not supported, ignoring");
+      return FALSE;
+    }
+  }
+
+  GST_DEBUG_OBJECT (obj->dbg_obj,
+      "Got composing left %u, top %u, size %ux%u", sel.r.left, sel.r.top,
+      sel.r.width, sel.r.height);
+
+  *compose_rect = sel.r;
+
+  return TRUE;
+}
+
 /**
  * gst_v4l2_object_set_crop:
  * @obj: the object
diff --git a/sys/v4l2/gstv4l2object.h b/sys/v4l2/gstv4l2object.h
index 5223cbb..c0744f9 100644
--- a/sys/v4l2/gstv4l2object.h
+++ b/sys/v4l2/gstv4l2object.h
@@ -329,6 +329,7 @@ gboolean     gst_v4l2_object_is_raw (GstV4l2Object * obj);
 gboolean     gst_v4l2_object_set_crop (GstV4l2Object * obj, struct v4l2_rect *result);
 gboolean     gst_v4l2_object_get_crop_bounds (GstV4l2Object * obj, struct v4l2_rect *bounds);
 gboolean     gst_v4l2_object_get_crop_default (GstV4l2Object * obj, struct v4l2_rect *bounds);
+gboolean     gst_v4l2_object_set_compose (GstV4l2Object * obj, struct v4l2_rect *compose_rect);
 
 /* TODO Move to proper namespace */
 /* open/close the device */
diff --git a/sys/v4l2/gstv4l2transform.c b/sys/v4l2/gstv4l2transform.c
index e485299..7272ab1 100644
--- a/sys/v4l2/gstv4l2transform.c
+++ b/sys/v4l2/gstv4l2transform.c
@@ -48,7 +48,8 @@ enum
 {
   PROP_0,
   V4L2_STD_OBJECT_PROPS,
-  PROP_DISABLE_PASSTHROUGH
+  PROP_DISABLE_PASSTHROUGH,
+  PROP_SELECTION_TARGETS,
 };
 
 typedef struct
@@ -62,6 +63,158 @@ typedef struct
 G_DEFINE_ABSTRACT_TYPE (GstV4l2Transform, gst_v4l2_transform,
     GST_TYPE_BASE_TRANSFORM);
 
+static void
+gst_v4l2_transform_selection_targets_apply (GstV4l2Transform * self)
+{
+  GST_OBJECT_LOCK (self);
+
+
+  if (self->selection_targets.compose_capture_need_config) {
+    struct v4l2_rect rect = {
+      .left = self->selection_targets.compose_capture_rect.x,
+      .top = self->selection_targets.compose_capture_rect.y,
+      .width = self->selection_targets.compose_capture_rect.w,
+      .height = self->selection_targets.compose_capture_rect.h,
+    };
+
+    if (!gst_v4l2_object_set_compose (self->v4l2capture, &rect))
+      GST_WARNING_OBJECT (self, "Failed to configure compose for capture");
+    else
+      GST_DEBUG_OBJECT (self,
+          "Configure compose for capture. left/top/width/height: %d %d %u %u",
+          rect.left, rect.top, rect.width, rect.height);
+
+    self->selection_targets.compose_capture_need_config = FALSE;
+  }
+
+  if (self->selection_targets.crop_capture_need_config) {
+    struct v4l2_rect rect = {
+      .left = self->selection_targets.crop_capture_rect.x,
+      .top = self->selection_targets.crop_capture_rect.y,
+      .width = self->selection_targets.crop_capture_rect.w,
+      .height = self->selection_targets.crop_capture_rect.h,
+    };
+
+    if (!gst_v4l2_object_set_crop (self->v4l2capture, &rect))
+      GST_WARNING_OBJECT (self, "Failed to configure crop for capture");
+    else
+      GST_DEBUG_OBJECT (self,
+          "Configure crop for capture. left/top/width/height: %d %d %u %u",
+          rect.left, rect.top, rect.width, rect.height);
+
+    self->selection_targets.crop_capture_need_config = FALSE;
+  }
+
+  if (self->selection_targets.crop_output_need_config) {
+    struct v4l2_rect rect = {
+      .left = self->selection_targets.crop_output_rect.x,
+      .top = self->selection_targets.crop_output_rect.y,
+      .width = self->selection_targets.crop_output_rect.w,
+      .height = self->selection_targets.crop_output_rect.h,
+    };
+
+    if (!gst_v4l2_object_set_crop (self->v4l2output, &rect))
+      GST_WARNING_OBJECT (self, "Failed to configure crop for output");
+    else
+      GST_DEBUG_OBJECT (self,
+          "Configure crop for output. left/top/width/height: %d %d %u %u",
+          rect.left, rect.top, rect.width, rect.height);
+
+    self->selection_targets.crop_output_need_config = FALSE;
+  }
+
+  GST_OBJECT_UNLOCK (self);
+}
+
+static void
+gst_v4l2_transform_selection_targets_config (GObject * object,
+    guint prop_id, const GValue * value, GParamSpec * pspec)
+{
+  const GstStructure *s = gst_value_get_structure (value);
+  GstV4l2Transform *self = GST_V4L2_TRANSFORM (object);
+
+  if (s != NULL) {
+    GST_OBJECT_LOCK (self);
+
+    if (s &&
+        gst_structure_has_field (s, "compose-capture-x") &&
+        gst_structure_has_field (s, "compose-capture-y") &&
+        gst_structure_has_field (s, "compose-capture-w") &&
+        gst_structure_has_field (s, "compose-capture-h")) {
+
+      gst_structure_get_int (s, "compose-capture-x",
+          &(self->selection_targets.compose_capture_rect.x));
+      gst_structure_get_int (s, "compose-capture-y",
+          &(self->selection_targets.compose_capture_rect.y));
+      gst_structure_get_int (s, "compose-capture-w",
+          &(self->selection_targets.compose_capture_rect.w));
+      gst_structure_get_int (s, "compose-capture-h",
+          &(self->selection_targets.compose_capture_rect.h));
+
+      self->selection_targets.compose_capture_need_config = TRUE;
+
+      GST_DEBUG_OBJECT (self,
+          "The compose configure for capture x,y,w,h : %d,%d,%d,%d",
+          self->selection_targets.compose_capture_rect.x,
+          self->selection_targets.compose_capture_rect.y,
+          self->selection_targets.compose_capture_rect.w,
+          self->selection_targets.compose_capture_rect.h);
+    }
+
+    if (s &&
+        gst_structure_has_field (s, "crop-capture-x") &&
+        gst_structure_has_field (s, "crop-capture-y") &&
+        gst_structure_has_field (s, "crop-capture-w") &&
+        gst_structure_has_field (s, "crop-capture-h")) {
+
+      gst_structure_get_int (s, "crop-capture-x",
+          &(self->selection_targets.crop_capture_rect.x));
+      gst_structure_get_int (s, "crop-capture-y",
+          &(self->selection_targets.crop_capture_rect.y));
+      gst_structure_get_int (s, "crop-capture-w",
+          &(self->selection_targets.crop_capture_rect.w));
+      gst_structure_get_int (s, "crop-capture-h",
+          &(self->selection_targets.crop_capture_rect.h));
+
+      self->selection_targets.crop_capture_need_config = TRUE;
+
+      GST_DEBUG_OBJECT (self,
+          "The crop configure for capture x,y,w,h : %d,%d,%d,%d",
+          self->selection_targets.crop_capture_rect.x,
+          self->selection_targets.crop_capture_rect.y,
+          self->selection_targets.crop_capture_rect.w,
+          self->selection_targets.crop_capture_rect.h);
+    }
+
+    if (s &&
+        gst_structure_has_field (s, "crop-output-x") &&
+        gst_structure_has_field (s, "crop-output-y") &&
+        gst_structure_has_field (s, "crop-output-w") &&
+        gst_structure_has_field (s, "crop-output-h")) {
+
+      gst_structure_get_int (s, "crop-output-x",
+          &(self->selection_targets.crop_output_rect.x));
+      gst_structure_get_int (s, "crop-output-y",
+          &(self->selection_targets.crop_output_rect.y));
+      gst_structure_get_int (s, "crop-output-w",
+          &(self->selection_targets.crop_output_rect.w));
+      gst_structure_get_int (s, "crop-output-h",
+          &(self->selection_targets.crop_output_rect.h));
+
+      self->selection_targets.crop_output_need_config = TRUE;
+
+      GST_DEBUG_OBJECT (self,
+          "The crop configure for output x,y,w,h : %d,%d,%d,%d",
+          self->selection_targets.crop_output_rect.x,
+          self->selection_targets.crop_output_rect.y,
+          self->selection_targets.crop_output_rect.w,
+          self->selection_targets.crop_output_rect.h);
+    }
+
+    GST_OBJECT_UNLOCK (self);
+  }
+}
+
 static void
 gst_v4l2_transform_set_property (GObject * object,
     guint prop_id, const GValue * value, GParamSpec * pspec)
@@ -76,7 +229,10 @@ gst_v4l2_transform_set_property (GObject * object,
     case PROP_DISABLE_PASSTHROUGH:
       self->disable_passthrough = g_value_get_boolean (value);
       break;
-
+    case PROP_SELECTION_TARGETS:
+      gst_v4l2_transform_selection_targets_config (object, prop_id, value,
+          pspec);
+      break;
       /* By default, only set on output */
     default:
       if (!gst_v4l2_object_set_property_helper (self->v4l2output,
@@ -929,6 +1085,8 @@ gst_v4l2_transform_prepare_output_buffer (GstBaseTransform * trans,
       goto activate_failed;
   }
 
+  gst_v4l2_transform_selection_targets_apply (self);
+
   GST_DEBUG_OBJECT (self, "Queue input buffer");
   ret =
       gst_v4l2_buffer_pool_process (GST_V4L2_BUFFER_POOL (pool), &inbuf, NULL);
@@ -1171,6 +1329,16 @@ gst_v4l2_transform_class_init (GstV4l2TransformClass * klass)
       g_param_spec_boolean ("disable-passthrough", "Disable Passthrough",
           "Forces passing buffers through the converter", FALSE,
           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (gobject_class, PROP_SELECTION_TARGETS,
+      g_param_spec_boxed ("selection-targets", "Selection Targets",
+          "Configure the cropping and composing regions. "
+          "A structure type containing one or more of the following groups of fields: "
+          "group 1) compose-capture-x, compose-capture-y, compose-capture-w, compose-capture-h. "
+          "group 2) crop-capture-x, crop-capture-y, crop-capture-w, crop-capture-h. "
+          "group 3) crop-output-x, crop-output-y, crop-output-w, crop-output-h. "
+          "eg: selection-targets=\"cid,compose-capture-x=100,compose-capture-y=100,"
+          "compose-capture-w=300,compose-capture-h=200\" ",
+          GST_TYPE_STRUCTURE, G_PARAM_WRITABLE | G_PARAM_STATIC_STRINGS));
 }
 
 static void
diff --git a/sys/v4l2/gstv4l2transform.h b/sys/v4l2/gstv4l2transform.h
index 29f3f3c..e8810f9 100644
--- a/sys/v4l2/gstv4l2transform.h
+++ b/sys/v4l2/gstv4l2transform.h
@@ -45,6 +45,19 @@ G_BEGIN_DECLS
 
 typedef struct _GstV4l2Transform GstV4l2Transform;
 typedef struct _GstV4l2TransformClass GstV4l2TransformClass;
+typedef struct _GstSelectionTargets GstSelectionTargets ;
+
+struct _GstSelectionTargets
+{
+  GstVideoRectangle compose_capture_rect;
+  gboolean compose_capture_need_config;
+
+  GstVideoRectangle crop_capture_rect;
+  gboolean crop_capture_need_config;
+
+  GstVideoRectangle crop_output_rect;
+  gboolean crop_output_need_config;
+};
 
 struct _GstV4l2Transform
 {
@@ -63,6 +76,8 @@ struct _GstV4l2Transform
   GstCaps *outcaps;
 
   gboolean disable_passthrough;
+
+  GstSelectionTargets selection_targets;
 };
 
 struct _GstV4l2TransformClass
-- 
2.45.2

