From c3be8f89df57a07fa4ae46074bc28c7aa197b3e0 Mon Sep 17 00:00:00 2001
From: "joshua.yang" <joshua.yang@realtek.com>
Date: Tue, 1 Jul 2025 20:34:11 +0800
Subject: [PATCH 1/1] Fix WVC1 can't decode issue
Upstream-Status: Inappropriate [rtk specific]

---
 sys/v4l2/gstv4l2object.c | 69 +++++++++++++++++++++-------------------
 1 file changed, 37 insertions(+), 32 deletions(-)

diff --git a/sys/v4l2/gstv4l2object.c b/sys/v4l2/gstv4l2object.c
index 42875ec..c601709 100644
--- a/sys/v4l2/gstv4l2object.c
+++ b/sys/v4l2/gstv4l2object.c
@@ -1532,30 +1532,8 @@ gst_v4l2_object_v4l2fourcc_to_bare_struct (guint32 fourcc)
       break;
     case V4L2_PIX_FMT_VC1_ANNEX_G:
     case V4L2_PIX_FMT_VC1_ANNEX_L:
-      {
-        structure = gst_structure_new ("video/x-wmv",
-            "wmvversion", G_TYPE_INT, 3,
-            "stream-format", G_TYPE_STRING, "frame-layer",
-            "header-format", G_TYPE_STRING, "sequence-layer", NULL);
-
-        GValue list = G_VALUE_INIT;
-        g_value_init(&list, GST_TYPE_LIST);
-
-        GValue format1 = G_VALUE_INIT;
-        g_value_init(&format1, G_TYPE_STRING);
-        g_value_set_string(&format1, "WVC1");
-        gst_value_list_append_value(&list, &format1);
-
-        GValue format2 = G_VALUE_INIT;
-        g_value_init(&format2, G_TYPE_STRING);
-        g_value_set_string(&format2, "WMV3");
-        gst_value_list_append_value(&list, &format2);
-
-        gst_structure_set_value(structure, "format", &list);
-        g_value_unset(&format1);
-        g_value_unset(&format2);
-        g_value_unset(&list);
-      }
+      structure = gst_structure_new ("video/x-wmv",
+          "wmvversion", G_TYPE_INT, 3, NULL);
       break;
     case V4L2_PIX_FMT_VP8:
       structure = gst_structure_new_empty ("video/x-vp8");
@@ -5009,16 +4987,43 @@ gst_v4l2_object_probe_caps (GstV4l2Object * v4l2object, GstCaps * filter)
       gst_caps_unref (format_caps);
     }
 
-    tmp = gst_v4l2_object_probe_caps_for_format (v4l2object,
-        format->pixelformat, template);
-    if (tmp) {
-      gst_caps_append (ret, tmp);
+    if (format->pixelformat == V4L2_PIX_FMT_VC1_ANNEX_L ||
+        format->pixelformat == V4L2_PIX_FMT_VC1_ANNEX_G) {
 
-      /* Add a variant of the caps with the Interlaced feature so we can negotiate it if needed */
-      add_alternate_variant (v4l2object, ret, gst_caps_get_structure (ret,
-              gst_caps_get_size (ret) - 1));
-    }
+      GstCaps *vc1_caps = gst_caps_new_empty ();
+      GstStructure *s = gst_structure_copy (template);
 
+      if (format->pixelformat == V4L2_PIX_FMT_VC1_ANNEX_L) {
+        gst_structure_set (s,
+            "format", G_TYPE_STRING, "WMV3",
+            "header-format", G_TYPE_STRING, "sequence-layer",
+            "stream-format", G_TYPE_STRING, "frame-layer",
+            NULL);
+      } else if (format->pixelformat == V4L2_PIX_FMT_VC1_ANNEX_G) {
+        gst_structure_set (s,
+            "format", G_TYPE_STRING, "WVC1",
+            "header-format", G_TYPE_STRING, "asf",
+            "stream-format", G_TYPE_STRING, "bdu",
+            NULL);
+      }
+
+      gst_caps_append_structure (vc1_caps, s);
+      gst_caps_append (ret, vc1_caps);
+
+      add_alternate_variant (v4l2object, ret,
+          gst_caps_get_structure (ret, gst_caps_get_size (ret) - 1));
+
+    } else {
+      tmp = gst_v4l2_object_probe_caps_for_format (v4l2object,
+          format->pixelformat, template);
+      if (tmp) {
+        gst_caps_append (ret, tmp);
+
+        /* Add a variant of the caps with the Interlaced feature so we can negotiate it if needed */
+        add_alternate_variant (v4l2object, ret, gst_caps_get_structure (ret,
+                gst_caps_get_size (ret) - 1));
+      }
+    }
     gst_structure_free (template);
   }
 
-- 
2.34.1

